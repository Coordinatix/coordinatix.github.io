<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Black Hole — Centered, Physically-Inspired</title>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Inter,system-ui, Arial}
    #ui{position:fixed;left:12px;top:12px;color:#ddd;z-index:20;backdrop-filter:blur(6px)}
    .panel{background:rgba(0,0,0,0.45);padding:10px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.7)}
    label{display:block;font-size:13px;margin:6px 0}
    input[type=range]{width:200px}
    button{margin-top:6px;padding:6px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);background:rgba(255,255,255,0.02);color:#fff}
    #credits{position:fixed;right:12px;bottom:12px;color:#888;font-size:12px}
    #errorOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.85);color:#f66;display:flex;align-items:center;justify-content:center;z-index:9999;padding:20px;box-sizing:border-box;display:none}
    #errorOverlay .box{max-width:780px;background:rgba(20,10,10,0.6);padding:20px;border-radius:8px;border:1px solid rgba(255,100,100,0.08)}
    #errorOverlay h2{margin:0 0 8px 0;color:#fff}
    #errorOverlay p{color:#f88;margin:8px 0}
    #errorOverlay code{background:#111;color:#ffb;border-radius:4px;padding:2px 6px}
  </style>
</head>
<body>
  <div id="ui" class="panel">
    <div style="font-weight:600">Black Hole</div>
    <label>Mass (scale): <span id="massVal">1.0</span></label>
    <input id="mass" type="range" min="0.2" max="5" step="0.01" value="1.0">

    <label>Lens Strength: <span id="lensVal">0.6</span></label>
    <input id="lens" type="range" min="0" max="2" step="0.01" value="0.6">

    <label>Disk Brightness: <span id="diskVal">1.0</span></label>
    <input id="disk" type="range" min="0" max="3" step="0.01" value="1.0">

    <button id="toggleTrails">Toggle Photon Trails</button>
    <button id="toggleDiskWarp">Toggle Disk Warp</button>
    <div style="font-size:12px;color:#9aa; margin-top:6px">Use mouse to orbit/pan/zoom. Black body is centered.</div>
  </div>
  <div id="credits">Three.js • OrbitControls • aspect-correct lensing • horizon mask</div>

  <div id="errorOverlay"><div class="box"><h2>Module Load Error</h2>
    <p>The page failed to load local <code>three</code> modules. This build requires local relative imports (no CDN) to work in sandboxed environments.</p>
    <p>To fix, download the following files into the <code>same folder</code> as this HTML file:</p>
    <ul style="color:#ffc">
      <li><code>three.module.js</code> — from the Three.js build (e.g. <code>/build/three.module.js</code>).</li>
      <li><code>examples/jsm/controls/OrbitControls.js</code> — from the Three.js examples (maintain the folder structure <code>examples/jsm/controls/OrbitControls.js</code>).</li>
    </ul>
    <p>Then reload this page. If you prefer a CDN-based page, tell me and I'll provide a CDN version.</p>
  </div></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/OrbitControls.js"></script>

  <script>
  // Full rewrite: centered black hole, physically-inspired approximations,
  // horizon absorb mask, clamped photon life, disk occlusion via normal·view, disk from R->2R.

  window.addEventListener('load', function(){ (function(){
    const TH = THREE;
    const showError = (msg)=>{ const o=document.getElementById('errorOverlay'); o.style.display='flex'; console.error(msg); };

    // Renderer
    const renderer = new TH.WebGLRenderer({antialias:true, alpha:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    // Scene & camera (centered on origin where black hole will be)
    const scene = new TH.Scene();
    scene.background = new TH.Color(0x000000);

    const camera = new TH.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 20000);
    camera.position.set(0, 12, 70);
    camera.lookAt(0,0,0);

    const controls = new TH.OrbitControls(camera, renderer.domElement);
    controls.target.set(0,0,0);
    controls.enableDamping = true; controls.dampingFactor = 0.08;

    scene.add(new TH.AmbientLight(0xffffff, 0.5));

    // Parameters
    const BH_radius = 4.0; // visual event horizon radius (scene units)

    // Starfield
    const starsMat = new TH.MeshBasicMaterial({map: generateStarTexture(2048), side: TH.BackSide});
    const stars = new TH.Mesh(new TH.SphereGeometry(7000, 64, 64), starsMat);
    scene.add(stars);

    // Black hole (centered) — pure black, ensure no scaling
    const bhGeo = new TH.SphereGeometry(BH_radius, 64, 64);
    const bhMat = new TH.MeshBasicMaterial({color:0x000000});
    const blackHole = new TH.Mesh(bhGeo, bhMat);
    blackHole.position.set(0,0,0);
    scene.add(blackHole);

    // Accretion disk: inner=BH_radius, outer=2*BH_radius (wider as requested)
    const diskInner = BH_radius;
    const diskOuter = BH_radius * 2.0;
    const diskGeo = new TH.RingGeometry(diskInner, diskOuter, 512, 1);
    diskGeo.rotateX(Math.PI/2);

    // Disk shader material using normal · viewDir for correct face detection
    const diskMat = new TH.ShaderMaterial({
      transparent: true,
      side: TH.DoubleSide,
      uniforms: {
        time: { value: 0.0 },
        brightness: { value: 1.0 },
        cameraPos: { value: new TH.Vector3() }
      },
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vWorldPos;
        uniform float time;
        void main(){
          vUv = uv;
          // small rotation by radius for motion
          float angle = time * 0.6;
          float r = length(position.xz);
          float rotSpeed = 1.2 / (r + 0.05);
          mat2 R = mat2(cos(angle*rotSpeed), -sin(angle*rotSpeed), sin(angle*rotSpeed), cos(angle*rotSpeed));
          vec3 p = position;
          p.xz = R * p.xz;

          vNormal = normalize(normalMatrix * normal);
          vec4 worldPos = modelMatrix * vec4(p, 1.0);
          vWorldPos = worldPos.xyz;

          gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vWorldPos;
        uniform float time;
        uniform float brightness;
        uniform vec3 cameraPos;

        void main(){
          float r = abs(vUv.x - 0.5) * 2.0;
          vec3 innerC = vec3(1.0,0.72,0.2);
          vec3 outerC = vec3(0.75,0.28,0.06);
          float intensity = smoothstep(1.0, 0.0, pow(r, 1.2));
          float var = sin(time*2.0 + r*12.0) * 0.12 + 0.9;
          vec3 col = mix(innerC, outerC, r) * intensity * var * brightness;

          vec3 viewDir = normalize(cameraPos - vWorldPos);
          float facing = dot(normalize(vNormal), viewDir);
          float frontFactor = mix(0.12, 1.0, smoothstep(0.0, 0.25, facing));

          float innerFade = smoothstep(0.02, 0.0, r);
          float alpha = smoothstep(1.0, 0.2, r) * 0.98 * (frontFactor) * (1.0 - innerFade*0.95);

          col *= mix(vec3(0.7), vec3(1.0), frontFactor);
          vec4 outCol = vec4(col, alpha);
          if(outCol.a < 0.01) discard; // helps sorting/z-fighting
          gl_FragColor = outCol;
        }
      `
    });

    const disk = new TH.Mesh(diskGeo, diskMat);
    scene.add(disk);

    // Rim ring
    const rim = new TH.Mesh(new TH.RingGeometry(diskOuter*1.03, diskOuter*1.12, 256), new TH.MeshBasicMaterial({color:0xffaa66, transparent:true, opacity:0.06, side:TH.DoubleSide}));
    rim.rotateX(Math.PI/2); scene.add(rim);

    // Photon trails (CPU) with lifetime clamp to avoid multiple-orbit artifacts
    const MAX_TRAILS = 3000;
    const trailPositions = new Float32Array(MAX_TRAILS * 3);
    const trailGeo = new TH.BufferGeometry(); trailGeo.setAttribute('position', new TH.BufferAttribute(trailPositions, 3));
    const trailMat = new TH.PointsMaterial({ size: 0.08, color:0xffcc88, transparent:true, opacity:0.9 });
    trailMat.depthTest = true; trailMat.depthWrite = false;
    const trails = new TH.Points(trailGeo, trailMat);
    trails.renderOrder = 50; disk.renderOrder = 60; // render disk after trails by default
    scene.add(trails);

    const particles = [];
    const MAX_LIFE = 200; // frames
    function spawnParticle(i){
      const angle = (i / MAX_TRAILS) * Math.PI*2 + (Math.random()-0.5)*0.6;
      const dist = 180 + Math.random()*90;
      const pos = new TH.Vector3(Math.cos(angle)*dist, (Math.random()-0.5)*12, Math.sin(angle)*dist);
      const vel = new TH.Vector3().subVectors(new TH.Vector3(0,0,0), pos).normalize().multiplyScalar(0.9 + Math.random()*0.6);
      particles[i] = { pos, vel, life: Math.floor(Math.random()*MAX_LIFE*0.5) };
      trailPositions[i*3+0] = pos.x; trailPositions[i*3+1] = pos.y; trailPositions[i*3+2] = pos.z;
    }
    for(let i=0;i<MAX_TRAILS;i++) spawnParticle(i);

    // Render target for postprocessing
    const rtW = Math.min(window.innerWidth, 2048);
    const rtH = Math.min(window.innerHeight, 2048);
    const renderTarget = new TH.WebGLRenderTarget(rtW, rtH, { minFilter:TH.LinearFilter, magFilter:TH.LinearFilter, format:TH.RGBAFormat });

    const postUniforms = {
      tScene: { value: renderTarget.texture },
      resolution: { value: new TH.Vector2(rtW, rtH) },
      bhPos: { value: new TH.Vector2(0.5, 0.5) },
      strength: { value: 0.6 },
      horizonRadius: { value: 0.06 },
      photonOrbitMask: { value: 0.12 }
    };

    // aspect-correct lens shader + horizon mask + photon-orbit falloff
    const postMat = new TH.ShaderMaterial({
      uniforms: postUniforms,
      vertexShader: 'varying vec2 vUv; void main(){ vUv = uv; gl_Position = vec4(position,1.0); }',
      fragmentShader: `precision mediump float; varying vec2 vUv; uniform sampler2D tScene; uniform vec2 resolution; uniform vec2 bhPos; uniform float strength; uniform float horizonRadius; uniform float photonOrbitMask;
        void main(){ vec2 uv = vUv; float aspect = resolution.x / resolution.y; vec2 aspectScale = vec2(aspect, 1.0); vec2 p = (uv - bhPos) * aspectScale; float r = length(p);

        float horizonScreenR = horizonRadius * aspect;
        if(r < horizonScreenR * 0.98){ gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); return; }

        float orbitFall = smoothstep(photonOrbitMask*0.5, photonOrbitMask, r);
        float s = strength * (1.0 - clamp(orbitFall*0.9, 0.0, 0.95));

        vec2 dir = normalize(p + vec2(1e-6));
        vec2 dispScreen = -dir * s * (1.0 / (r * 6.0 + 0.001));
        vec2 disp = dispScreen / aspectScale;

        vec2 uvR = clamp(uv + disp * 0.9, vec2(0.0), vec2(1.0));
        vec2 uvG = clamp(uv + disp * 0.98, vec2(0.0), vec2(1.0));
        vec2 uvB = clamp(uv + disp * 1.05, vec2(0.0), vec2(1.0));

        vec4 cR = texture2D(tScene, uvR);
        vec4 cG = texture2D(tScene, uvG);
        vec4 cB = texture2D(tScene, uvB);
        gl_FragColor = vec4(cR.r, cG.g, cB.b, 1.0);
      }`
    });

    const quad = new TH.Mesh(new TH.PlaneGeometry(2,2), postMat);
    const postScene = new TH.Scene(); postScene.add(quad); const postCam = new TH.Camera();

    // UI bindings
    const massEl = document.getElementById('mass'); const massVal = document.getElementById('massVal'); massEl.addEventListener('input', ()=> massVal.textContent = massEl.value);
    const lensEl = document.getElementById('lens'); const lensVal = document.getElementById('lensVal'); lensEl.addEventListener('input', ()=>{ lensVal.textContent = lensEl.value; postUniforms.strength.value = parseFloat(lensEl.value); });
    const diskEl = document.getElementById('disk'); const diskVal = document.getElementById('diskVal'); diskEl.addEventListener('input', ()=>{ diskVal.textContent = diskEl.value; diskMat.uniforms.brightness.value = parseFloat(diskEl.value); });
    document.getElementById('toggleTrails').addEventListener('click', ()=>{ trails.visible = !trails.visible; });
    let diskWarp = false; document.getElementById('toggleDiskWarp').addEventListener('click', ()=>{ diskWarp = !diskWarp; });

    // update BH screen position and horizon radius
    const tmp = new TH.Vector3(); const tmp2 = new TH.Vector3();
    function updateBHInfo(){ tmp.copy(blackHole.position); tmp.project(camera); postUniforms.bhPos.value.set(tmp.x*0.5+0.5, tmp.y*0.5+0.5);
      camera.getWorldDirection(tmp2); const camRight = new TH.Vector3().crossVectors(camera.up, tmp2).normalize(); const offset = blackHole.position.clone().add(camRight.multiplyScalar(BH_radius)); offset.project(camera);
      const offsetUv = new TH.Vector2(offset.x*0.5+0.5, offset.y*0.5+0.5); postUniforms.horizonRadius.value = offsetUv.distanceTo(postUniforms.bhPos.value);
    }

    // resize
    function onResize(){ const w = Math.max(1, innerWidth), h = Math.max(1, innerHeight); renderer.setSize(w,h,false); camera.aspect = w/h; camera.updateProjectionMatrix(); const rtW = Math.min(w,2048), rtH = Math.min(h,2048); renderTarget.setSize(rtW, rtH); postUniforms.resolution.value.set(rtW, rtH); }
    window.addEventListener('resize', onResize, {passive:true}); onResize();

    // animation
    let last = performance.now();
    function animate(){ requestAnimationFrame(animate); const now = performance.now(); const dt = Math.min(0.05, (now - last)/1000); last = now;

      // update uniforms
      diskMat.uniforms.time.value += dt;
      diskMat.uniforms.cameraPos.value.copy(camera.position);

      // update particle physics (inverse-square), clamp life and absorb inside horizon
      const mass = parseFloat(massEl.value);
      const k = 120.0 * mass;
      for(let i=0;i<MAX_TRAILS;i++){
        const p = particles[i]; p.life += 1;
        const toBH = new TH.Vector3().subVectors(blackHole.position, p.pos);
        const r2 = Math.max(0.0001, toBH.lengthSq());
        const accel = toBH.normalize().multiplyScalar(k / r2);
        p.vel.add(accel.multiplyScalar(dt)); p.pos.add(p.vel.clone().multiplyScalar(dt));

        // absorb immediately if inside horizon
        if(p.pos.length() < BH_radius * 1.02){ spawnParticle(i); continue; }
        // clamp long-lived particles (prevent multiple-orbit buildup)
        if(p.life > MAX_LIFE){ spawnParticle(i); continue; }

        trailPositions[i*3+0] = p.pos.x; trailPositions[i*3+1] = p.pos.y; trailPositions[i*3+2] = p.pos.z;
      }
      trailGeo.attributes.position.needsUpdate = true;

      controls.update();

      // render scene into target
      renderer.setRenderTarget(renderTarget); renderer.clear(); renderer.render(scene, camera); renderer.setRenderTarget(null);

      // update BH info for shader
      updateBHInfo();

      if(diskWarp){ postUniforms.strength.value = Math.min(2.0, parseFloat(lensEl.value) * 1.3); } else { postUniforms.strength.value = parseFloat(lensEl.value); }

      // composite
      renderer.render(postScene, postCam);
    }
    animate();

    // helper: generate star texture
    function generateStarTexture(size=2048){ const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d'); ctx.fillStyle='#000'; ctx.fillRect(0,0,size,size); const count = Math.floor(size*4.5);
      for(let i=0;i<count;i++){ const x=Math.random()*size, y=Math.random()*size, r=Math.random()*1.2+0.3; const g=ctx.createRadialGradient(x,y,0,x,y,r*2); const bright=200+Math.floor(Math.random()*55); g.addColorStop(0, `rgba(${bright},${bright},${bright},1)`); g.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=g; ctx.fillRect(x-r-1,y-r-1,r*2+2,r*2+2); }
      const tex = new TH.CanvasTexture(c); tex.needsUpdate=true; return tex; }

  })(); });
  </script>
</body>
</html>
