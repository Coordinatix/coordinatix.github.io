<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coordinatix 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, sans-serif;
        }

        body {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #sidebar {
            width: 300px;
            background: #f4f4f4;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #ddd;
        }

        #sidebar h2 {
            font-size: 1.5em;
            margin-bottom: 20px;
        }

        .equation-container {
            margin-bottom: 15px;
        }

        .equation-input {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        button {
            padding: 8px 12px;
            margin: 5px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #007bff;
            color: white;
        }

        button:hover {
            background: #0056b3;
        }

        .remove-btn {
            background: #dc3545;
        }

        .remove-btn:hover {
            background: #b02a37;
        }

        #error {
            color: red;
            font-size: 0.9em;
            margin-top: 10px;
        }

        #canvas-container {
            flex-grow: 1;
            background: #000;
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            #sidebar {
                width: 100%;
                height: 40%;
                overflow-y: auto;
            }

            #canvas-container {
                height: 60%;
            }
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <h2>Coordinatix (Beta)</h2>
        <button onclick="addEquation()">Add Equation</button>
        <div id="equations"></div>
        <div id="error"></div>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.6.4/math.min.js"></script>
   <!-- Replace your <script> section with this -->
<script>
    let scene, camera, renderer, controls;
    const equations = [];
    const meshes = [];
    const resolution = 500;
    const range = 10;

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 10);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth - 300, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        const gridHelper = new THREE.GridHelper(20, 20);
        scene.add(gridHelper);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(10, 10, 10);
scene.add(directionalLight);


        window.addEventListener('resize', onWindowResize);
        animate();
    }

    function onWindowResize() {
        camera.aspect = (window.innerWidth - 300) / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth - 300, window.innerHeight);
    }

    function addEquation(equationText = '') {
        const index = equations.length;
        equations.push({ text: equationText, color: getRandomColor() });

        const container = document.createElement('div');
        container.className = 'equation-container';
        container.id = `equation-${index}`;

        const input = document.createElement('input');
        input.className = 'equation-input';
        input.placeholder = 'Enter equation (e.g., sin(x) + cos(y))';
        input.value = equationText;
        input.onchange = () => updateEquation(index, input.value);

        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-btn';
        removeBtn.innerText = 'Remove';
        removeBtn.onclick = () => removeEquation(index);

        container.appendChild(input);
        container.appendChild(removeBtn);
        document.getElementById('equations').appendChild(container);

        updateEquation(index, equationText);
    }

    function removeEquation(index) {
        equations[index] = null;
        if (meshes[index]) {
            scene.remove(meshes[index]);
            meshes[index].geometry.dispose();
            meshes[index].material.dispose();
            meshes[index] = null;
        }
        const container = document.getElementById(`equation-${index}`);
        if (container) container.remove();
    }

    function updateEquation(index, text) {
        equations[index].text = text;
        document.getElementById('error').innerText = '';

        try {
            const parser = math.parser();
            parser.evaluate(`f(x, y) = ${text || '0'}`);
            generateGraph(index);
        } catch (e) {
            document.getElementById('error').innerText = `Error in equation ${index + 1}: ${e.message}`;
            if (meshes[index]) {
                scene.remove(meshes[index]);
                meshes[index].geometry.dispose();
                meshes[index].material.dispose();
                meshes[index] = null;
            }
        }
    }

    function generateGraph(index) {
        if (meshes[index]) {
            scene.remove(meshes[index]);
            meshes[index].geometry.dispose();
            meshes[index].material.dispose();
        }

        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const colors = [];
        const color = new THREE.Color(equations[index].color);

        const parser = math.parser();
        parser.evaluate(`f(x, y) = ${equations[index].text || '0'}`);

        for (let i = 0; i <= resolution; i++) {
            for (let j = 0; j <= resolution; j++) {
                const x = (i / resolution) * 2 * range - range;
                const y = (j / resolution) * 2 * range - range;
                let z;
                try {
                    z = parser.evaluate(`f(${x}, ${y})`);
                    if (isNaN(z) || !isFinite(z)) z = 0;
                } catch {
                    z = 0;
                }
                vertices.push(x, y, z);
                colors.push(color.r, color.g, color.b);
            }
        }

        const indices = [];
        for (let i = 0; i < resolution; i++) {
            for (let j = 0; j < resolution; j++) {
                const a = i * (resolution + 1) + j;
                const b = a + 1;
                const c = (i + 1) * (resolution + 1) + j;
                const d = c + 1;
                indices.push(a, b, d);
                indices.push(a, d, c);
            }
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setIndex(indices);

       const material = new THREE.MeshStandardMaterial({
     vertexColors: true,
     side: THREE.DoubleSide,
     flatShading: true,
     metalness: 0.1,
     roughness: 0.8
     });

        const mesh = new THREE.Mesh(geometry, material);
        meshes[index] = mesh;
        scene.add(mesh);
    }

    function getRandomColor() {
        return `#${Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0')}`;
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    // Initialize with one equation
    init();
    addEquation('sin(x) + cos(y)');
</script>

</body>
</html>