<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Black Hole Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <!-- dat.GUI via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

    <!-- Import map for Three.js modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.180.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.180.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // --- Configuration ---
        let NUM_PARTICLES = 2000;
        let G_CONSTANT = 5000;
        let BLACK_HOLE_MASS = 1000000;
        let EVENT_HORIZON_RADIUS = 5;
        const ACCRETION_DISK_INNER_RADIUS = EVENT_HORIZON_RADIUS * 1.5;
        const ACCRETION_DISK_OUTER_RADIUS = EVENT_HORIZON_RADIUS * 30;
        const PARTICLE_INITIAL_VELOCITY_MAGNITUDE = 20;
        const SPAWN_RADIUS_MIN = ACCRETION_DISK_OUTER_RADIUS * 1.5;
        const SPAWN_RADIUS_MAX = SPAWN_RADIUS_MIN + 100;
        const PARTICLE_LIFESPAN = 20;
        const SCENE_SIZE = 500;
        const TRAIL_LENGTH = 5;
        const TRAIL_SEGMENTS = TRAIL_LENGTH - 1;
        const VERTS_PER_TRAIL = TRAIL_SEGMENTS * 2;

        // --- Global objects ---
        let scene, camera, renderer, controls, composer, renderPass, lensingPass;
        let blackHole;
        let particles = [];
        let particleGeometry, particleMaterial, particleSystem;
        let trailGeometry, trailMaterial, trailSystem;
        let starField;

        // Buffers
        let positions = new Float32Array(NUM_PARTICLES * 3);
        let colors = new Float32Array(NUM_PARTICLES * 3);
        let activeParticlesCount = 0;

        let trailPositions = new Float32Array(NUM_PARTICLES * VERTS_PER_TRAIL * 3);
        let trailColors = new Float32Array(NUM_PARTICLES * VERTS_PER_TRAIL * 3);

        // --- Time tracking ---
        let clock = new THREE.Clock();
        let width, height;

        // --- Lensing Shader ---
        const lensingShader = {
            uniforms: {
                tDiffuse: { value: null },
                center: { value: new THREE.Vector2(0.5, 0.5) },
                strength: { value: 0.3 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 center;
                uniform float strength;
                varying vec2 vUv;
                void main() {
                    vec2 disp = vUv - center;
                    float dist = length(disp);
                    if (dist < 0.01) {
                        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                        return;
                    }
                    vec2 distortion = normalize(disp) * (strength / (dist * dist + 0.01));
                    vec2 distortedUv = vUv + distortion;
                    gl_FragColor = texture2D(tDiffuse, distortedUv);
                }
            `
        };

        // --- BlackHole Class ---
        class BlackHole {
            constructor(x, y, z, mass, eventHorizonRadius) {
                this.position = new THREE.Vector3(x, y, z);
                this.mass = mass;
                this.eventHorizonRadius = eventHorizonRadius;

                const bhGeometry = new THREE.SphereGeometry(eventHorizonRadius, 32, 32);
                const bhMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                this.mesh = new THREE.Mesh(bhGeometry, bhMaterial);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);

                const diskGeometry = new THREE.RingGeometry(ACCRETION_DISK_INNER_RADIUS, ACCRETION_DISK_OUTER_RADIUS, 64);
                const diskMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFF8C00,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                this.disk = new THREE.Mesh(diskGeometry, diskMaterial);
                this.disk.position.copy(this.position);
                this.disk.rotation.x = -Math.PI / 2;
                scene.add(this.disk);
            }

            updateMass(newMass) {
                this.mass = newMass;
            }

            updateRadius(newRadius) {
                this.eventHorizonRadius = newRadius;
                this.mesh.scale.setScalar(newRadius / EVENT_HORIZON_RADIUS);
            }
        }

        // --- Particle Class ---
        class Particle {
            constructor() {
                this.position = new THREE.Vector3();
                this.velocity = new THREE.Vector3();
                this.acceleration = new THREE.Vector3();
                this.prevPosition = new THREE.Vector3();
                this.trailPositions = [];
                this.mass = 1;
                this.isAlive = false;
                this.lifespan = PARTICLE_LIFESPAN;
                this.timeAlive = 0;
                this.color = new THREE.Color();
                this.index = -1;
            }

            init(index, spawnPos, spawnVel, color) {
                this.index = index;
                this.position.copy(spawnPos);
                this.velocity.copy(spawnVel);
                this.acceleration.set(0, 0, 0);
                this.prevPosition.copy(this.position);
                this.trailPositions = [this.position.clone()];
                this.isAlive = true;
                this.timeAlive = 0;
                this.color.copy(color);
                this.updateGeometry();
            }

            update(blackHole, G_constant, deltaTime) {
                if (!this.isAlive) return;

                const direction = blackHole.position.clone().sub(this.position);
                let distance = direction.length();

                const MIN_DIST = 0.1;
                if (distance < MIN_DIST) distance = MIN_DIST;

                direction.normalize();

                let forceMagnitude = (G_constant * blackHole.mass * this.mass) / (distance * distance);

                if (distance < blackHole.eventHorizonRadius * 20) {
                    const proximityFactor = 1 - (distance / (blackHole.eventHorizonRadius * 20));
                    forceMagnitude *= (1 + proximityFactor * 10);
                }

                const force = direction.multiplyScalar(forceMagnitude);
                this.acceleration.copy(force).divideScalar(this.mass);

                this.velocity.add(this.acceleration.clone().multiplyScalar(deltaTime));
                this.velocity.multiplyScalar(0.999);

                const MAX_VELOCITY = 1000;
                if (this.velocity.length() > MAX_VELOCITY) {
                    this.velocity.normalize().multiplyScalar(MAX_VELOCITY);
                }

                this.prevPosition.copy(this.position);

                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));

                const newDistance = blackHole.position.clone().sub(this.position).length();
                if (newDistance < blackHole.eventHorizonRadius) {
                    this.isAlive = false;
                }

                this.timeAlive += deltaTime;
                if (this.timeAlive > this.lifespan) {
                    this.isAlive = false;
                }

                this.trailPositions.push(this.position.clone());
                if (this.trailPositions.length > TRAIL_LENGTH) {
                    this.trailPositions.shift();
                }

                this.updateGeometry();
            }

            updateGeometry() {
                if (this.index !== -1) {
                    const posBase = this.index * 3;
                    const trailBase = this.index * VERTS_PER_TRAIL * 3;
                    const trailColorBase = this.index * VERTS_PER_TRAIL * 3;

                    if (this.isAlive) {
                        positions[posBase] = this.position.x;
                        positions[posBase + 1] = this.position.y;
                        positions[posBase + 2] = this.position.z;

                        colors[posBase] = this.color.r;
                        colors[posBase + 1] = this.color.g;
                        colors[posBase + 2] = this.color.b;

                        let tpIdx = 0;
                        for (let j = 0; j < Math.min(this.trailPositions.length - 1, TRAIL_SEGMENTS); j++) {
                            trailPositions[trailBase + tpIdx++] = this.trailPositions[j].x;
                            trailPositions[trailBase + tpIdx++] = this.trailPositions[j].y;
                            trailPositions[trailBase + tpIdx++] = this.trailPositions[j].z;
                            trailPositions[trailBase + tpIdx++] = this.trailPositions[j + 1].x;
                            trailPositions[trailBase + tpIdx++] = this.trailPositions[j + 1].y;
                            trailPositions[trailBase + tpIdx++] = this.trailPositions[j + 1].z;
                        }
                        while (tpIdx < VERTS_PER_TRAIL * 3) {
                            trailPositions[trailBase + tpIdx++] = SCENE_SIZE * 2;
                        }

                        let tcIdx = 0;
                        for (let j = 0; j < Math.min(this.trailPositions.length - 1, TRAIL_SEGMENTS); j++) {
                            const fade = 1.0 - (j / (TRAIL_LENGTH - 1)) * 0.5;
                            const r = this.color.r * fade;
                            const g = this.color.g * fade;
                            const b = this.color.b * fade;
                            trailColors[trailColorBase + tcIdx++] = r;
                            trailColors[trailColorBase + tcIdx++] = g;
                            trailColors[trailColorBase + tcIdx++] = b;
                            trailColors[trailColorBase + tcIdx++] = r;
                            trailColors[trailColorBase + tcIdx++] = g;
                            trailColors[trailColorBase + tcIdx++] = b;
                        }
                        while (tcIdx < VERTS_PER_TRAIL * 3) {
                            trailColors[trailColorBase + tcIdx++] = 0;
                        }
                    } else {
                        positions[posBase] = SCENE_SIZE * 2;
                        positions[posBase + 1] = SCENE_SIZE * 2;
                        positions[posBase + 2] = SCENE_SIZE * 2;

                        colors[posBase] = 0;
                        colors[posBase + 1] = 0;
                        colors[posBase + 2] = 0;

                        for (let k = 0; k < VERTS_PER_TRAIL * 3; k++) {
                            trailPositions[trailBase + k] = SCENE_SIZE * 2;
                            trailColors[trailColorBase + k] = 0;
                        }
                    }
                }
            }
        }

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Starry Background
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = new Float32Array(10000 * 3);
            for (let i = 0; i < 10000; i++) {
                starPositions[i * 3] = (Math.random() - 0.5) * SCENE_SIZE * 4;
                starPositions[i * 3 + 1] = (Math.random() - 0.5) * SCENE_SIZE * 4;
                starPositions[i * 3 + 2] = (Math.random() - 0.5) * SCENE_SIZE * 4;
            }
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1, sizeAttenuation: false });
            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffaa00, 1, 200);
            pointLight.position.set(0, 20, 0);
            scene.add(pointLight);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 100, 200);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            width = window.innerWidth;
            height = window.innerHeight;

            // Post-processing
            composer = new EffectComposer(renderer);
            renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const lensingMaterial = new THREE.ShaderMaterial(lensingShader);
            lensingPass = new ShaderPass(lensingMaterial);
            lensingPass.renderToScreen = true;
            composer.addPass(lensingPass);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.maxPolarAngle = Math.PI / 2;

            // Black Hole
            blackHole = new BlackHole(0, 0, 0, BLACK_HOLE_MASS, EVENT_HORIZON_RADIUS);

            // Particle System
            particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            particleMaterial = new THREE.PointsMaterial({
                size: 0.8,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                sizeAttenuation: true
            });

            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);

            // Trail System
            trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));

            trailMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                linewidth: 1
            });

            trailSystem = new THREE.LineSegments(trailGeometry, trailMaterial);
            scene.add(trailSystem);

            // Particles
            for (let i = 0; i < NUM_PARTICLES; i++) {
                particles.push(new Particle());
            }

            // GUI
            const settings = {
                G: G_CONSTANT,
                mass: BLACK_HOLE_MASS,
                radius: EVENT_HORIZON_RADIUS
            };
            const gui = new dat.GUI();
            gui.add(settings, 'G', 1000, 20000).onChange((v) => { G_CONSTANT = v; });
            gui.add(settings, 'mass', 100000, 5000000).onChange((v) => { BLACK_HOLE_MASS = v; blackHole.updateMass(v); });
            gui.add(settings, 'radius', 1, 20).onChange((v) => { EVENT_HORIZON_RADIUS = v; blackHole.updateRadius(v); });

            // Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('click', spawnParticlesAtCamera);

            animate();
        }

        function onWindowResize() {
            width = window.innerWidth;
            height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            composer.setSize(width, height);
        }

        // --- Spawning ---
        function spawnParticle(index) {
            const particle = particles[index];

            const radius = THREE.MathUtils.randFloat(SPAWN_RADIUS_MIN, SPAWN_RADIUS_MAX);
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.random() * Math.PI;

            const spawnPos = new THREE.Vector3(
                radius * Math.sin(theta) * Math.cos(phi),
                radius * Math.sin(theta) * Math.sin(phi),
                radius * Math.cos(theta)
            );

            const directionToBH = blackHole.position.clone().sub(spawnPos).normalize();
            const upVector = new THREE.Vector3(0, 1, 0);
            let perpendicular1 = new THREE.Vector3().crossVectors(directionToBH, upVector).normalize();
            if (perpendicular1.length() < 0.1) {
                perpendicular1 = new THREE.Vector3(1, 0, 0).cross(directionToBH).normalize();
            }
            const perpendicular2 = new THREE.Vector3().crossVectors(directionToBH, perpendicular1).normalize();

            const initialSpeed = PARTICLE_INITIAL_VELOCITY_MAGNITUDE + Math.random() * 5;
            const spawnVel = perpendicular1.multiplyScalar(initialSpeed * (Math.random() > 0.5 ? 1 : -1))
                                   .add(perpendicular2.multiplyScalar(initialSpeed * (Math.random() > 0.5 ? 1 : -1)))
                                   .add(directionToBH.multiplyScalar(initialSpeed * 0.1));

            const hue = Math.random();
            const color = new THREE.Color().setHSL(hue, 0.8, 0.7);

            particle.init(index, spawnPos, spawnVel, color);
        }

        function spawnParticlesAtCamera(event) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            mouse.x = (event.clientX / width) * 2 - 1;
            mouse.y = -(event.clientY / height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const spawnDistance = SPAWN_RADIUS_MAX * 1.5;
            const spawnPoint = raycaster.ray.at(spawnDistance, new THREE.Vector3());

            const numBurstParticles = 200;
            let particlesSpawned = 0;

            for (let i = 0; i < NUM_PARTICLES; i++) {
                if (!particles[i].isAlive && particlesSpawned < numBurstParticles) {
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50
                    );
                    const burstSpawnPos = spawnPoint.clone().add(offset);

                    const initialDirection = blackHole.position.clone().sub(burstSpawnPos).normalize();
                    const initialSpeed = PARTICLE_INITIAL_VELOCITY_MAGNITUDE * 0.5 + Math.random() * PARTICLE_INITIAL_VELOCITY_MAGNITUDE;
                    const burstSpawnVel = initialDirection.multiplyScalar(initialSpeed);

                    const hue = Math.random();
                    const color = new THREE.Color().setHSL(hue, 0.8, 0.7);

                    particles[i].init(i, burstSpawnPos, burstSpawnVel, color);
                    particlesSpawned++;
                }
            }
        }

        // --- Animation ---
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();
            controls.update();

            // Lensing center
            const vector = blackHole.position.clone();
            vector.project(camera);
            lensingShader.uniforms.center.value.x = (vector.x * 0.5 + 0.5);
            lensingShader.uniforms.center.value.y = (vector.y * 0.5 + 0.5);

            // Update particles
            let newActiveCount = 0;
            for (let i = 0; i < NUM_PARTICLES; i++) {
                const particle = particles[i];
                if (!particle.isAlive) {
                    spawnParticle(i);
                }
                particle.update(blackHole, G_CONSTANT, deltaTime);
                if (particle.isAlive) {
                    newActiveCount++;
                }
            }
            activeParticlesCount = newActiveCount;

            // Geometries
            particleGeometry.attributes.position.needsUpdate = true;
            particleGeometry.attributes.color.needsUpdate = true;
            trailGeometry.attributes.position.needsUpdate = true;
            trailGeometry.attributes.color.needsUpdate = true;

            blackHole.disk.rotation.z += deltaTime * 0.5;

            composer.render();
        }

        // Start
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>