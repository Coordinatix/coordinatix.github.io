<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale  <script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css">
  <title>Coordinatix 3D </title>
  <style>
    /* --- CSS unchanged from your original code --- */
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
    body, html { width: 100%; height: 100%; overflow: auto; }
    #canvas-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; background-color: #000; overflow: hidden; }
    #sidebar { position: fixed; top: 30px; left: 30px; width: 300px; height: calc(100vh - 60px); overflow-y: auto; padding: 20px; background: rgba(255, 255, 255, 0.2); border-radius: 16px; z-index: 10; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3); backdrop-filter: blur(10px); color: #fff; }
    #sidebar h2 { font-size: 1.5em; margin-bottom: 20px; }
    .equation-input { width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid rgba(255,255,255,0.4); border-radius: 6px; background: rgba(255, 255, 255, 0.3); color: #fff; }
    .equation-row { display: flex; align-items: center; margin-bottom: 10px; }
    .equation-input { 
      flex: 1; 
      padding: 0; 
      border: 1px solid rgba(255, 255, 255, 0.4) !important; 
      border-radius: 6px 0 0 6px; 
      background: rgba(255, 255, 255, 0.05); 
      color: #ffffff; 
      margin: 0;
      font-size: 14px;
      font-family: 'STIX Two Math', serif;
      position: relative;
      min-height: 42px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      overflow: visible;
      z-index: 0;
    }
    button { padding: 10px 14px; margin: 5px 0; border: none; border-radius: 6px; cursor: pointer; background: #00aaff; color: white; transition: background 0.2s ease; }
    button:hover { background: #0077cc00; }
    .remove-btn { padding: 10px 14px; background: rgba(255, 80, 80, 0); color: white; border: none; cursor: pointer; border-radius: 0 6px 6px 0; height: 100%; font-size: 1.2em; }
    .remove-btn:hover { transform: scale(1.2); }
    #error { color: #ff8888; font-size: 0.9em; margin-top: 10px; }
    @media (max-width: 768px) { #sidebar { width: 90%; left: 5%; } }

    /* MathQuill styling that preserves your UI */
    .equation-input.empty::before {
      content: attr(data-placeholder);
      color: rgba(255, 255, 255, 0.5);
      position: absolute;
      top: 50%;
      left: 10px;
      transform: translateY(-50%);
      pointer-events: none;
      font-family: 'STIX Two Math', serif;
      font-size: 14px;
      z-index: 0;
    }

    .equation-input .mq-editable-field {
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
      width: 100%  !important;
      padding: 0 !important;
      position: relative !important;
      left: auto !important;
      top: auto !important;
      transform: none !important;
      min-height: 38px !important;
      display: flex !important;
      align-items: center !important;
    }

    .equation-input .mq-root-block {
      display: flex !important;
      align-items: center !important;
      width: 100% !important;
      min-height: 38px !important;
      padding: 0 !important;
      margin: 0 !important;
    }

    .equation-input .mq-math-mode {
      background: transparent !important;
    }

    .mq-root-block,
    .mq-editable-field,
    .mq-math-mode,
    .mq-root-block span,
    .mq-numeral {
      font-family: 'STIX Two Math', 'Times New Roman', serif !important;
      font-size: 14px !important;
      color: inherit;
    }
    
    /* Make sure the border shows through */
    .equation-input .mq-math-mode {
      border: none !important;
      box-shadow: none !important;
    }
     
    /* Make exponents rise higher and look smaller */
.mq-sup {
  vertical-align: super !important;
  font-size: 0.7em !important; /* make it smaller */
  position: relative !important;
  top: -0.3em !important;      /* push it up */
}


    /* Ensure MathQuill doesn't overflow */
    .equation-input .mq-root-block {
      padding: 10px !important;
    }
      
    .equation-input:focus-within {
      box-shadow: 0 0 8px 2px #dce7e567; 
     border-radius: 6px;
     
}


    .mq-cursor {
      border-left: 1px solid white !important;
      animation: blink 1s steps(1) infinite;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>Coordinatix</h2>
    <div id="equations"></div>
    <div id="error"></div>
  </div>
  <div id="canvas-container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.0/math.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js"></script>
  <script>
    var MQ = MathQuill.getInterface(2);
  </script>


  <script>
    let scene, camera, renderer, controls, typingTimer;
    const equations = [];
    const meshes = [];
    const range = 10;
    const resolution = 200; // Reduced for better performance
    const typingDelay = 100; // milliseconds

    // Check if parentheses are balanced
    function isBalanced(str) {
      let stack = [];
      for (let ch of str) {
        if ("([{".includes(ch)) stack.push(ch);
        if (")]}".includes(ch)) {
          const last = stack.pop();
          if (!last || "([{".indexOf(last) !== ")]}".indexOf(ch)) return false;
        }
      }
      return stack.length === 0;
    }

    // Preprocess equation for implicit multiplication
    function preprocess(expr) {
      return expr
        .replace(/(\d)([a-zA-Z])/g, '$1*$2')   // 2x -> 2*x
        .replace(/([a-zA-Z])(\d)/g, '$1*$2')   // x2 -> x*2
        .replace(/\)([a-zA-Z\d(])/g, ')*$1')   // )x -> )*x, )(  -> )*(
        .replace(/([a-zA-Z\d])\(/g, '$1*(');   // x( -> x*(
    }

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(5, 5, 10);

      renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.AxesHelper(5));
      scene.add(new THREE.GridHelper(20, 20));
      // Soft upper right corner lighting setup
      scene.add(new THREE.AmbientLight(0xffffff, 0.35));
      
      // Softer main light from upper-right corner
      const cornerLight = new THREE.DirectionalLight(0xffffff, 0.75);
      cornerLight.position.set(12, 10, 8);
      cornerLight.castShadow = true;
      cornerLight.shadow.mapSize.width = 2048;
      cornerLight.shadow.mapSize.height = 2048;
      cornerLight.shadow.radius = 2; // Add some shadow softening
      scene.add(cornerLight);
      
      // Slightly stronger fill light for softer shadows
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.15);
      fillLight.position.set(-2, 0, 2);
      scene.add(fillLight);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    }

    // Converts a math.js AST to GLSL-safe code
function mathjsToGLSL(node) {
  switch (node.type) {
    case 'SymbolNode':
      if (['x', 'y', 'z', 't'].includes(node.name)) return node.name;
      if (node.name === 'pi') return '3.14159265359';
      if (node.name === 'e') return '2.71828182846';
      throw new Error(`Unsupported variable: ${node.name}`);

    case 'ConstantNode':
      const val = Number(node.value);
      return Number.isInteger(val) ? `${val}.0` : `${val}`;

    case 'OperatorNode':
      const [a, b] = node.args.map(mathjsToGLSL);
      switch (node.op) {
        case '+': return `(${a} + ${b})`;
        case '-': return `(${a} - ${b})`;
        case '*': return `(${a} * ${b})`;
        case '/': return `(${a} / ${b})`;
        case '^': return `pow(${a}, ${b})`;
        default: throw new Error(`Unsupported operator: ${node.op}`);
      }

    case 'FunctionNode': {
      const fn = node.fn.name;   // ✅ use fn.name instead of node.name
      const args = node.args.map(mathjsToGLSL).join(', ');
      const supported = {
        sin: 'sin', cos: 'cos', tan: 'tan',
        asin: 'asin', acos: 'acos', atan: 'atan', atan2: 'atan',
        sinh: 'sinh', cosh: 'cosh', tanh: 'tanh',
        exp: 'exp', log: 'log', sqrt: 'sqrt', abs: 'abs'
      };
      if (supported[fn]) return `${supported[fn]}(${args})`;
      throw new Error(`Unsupported function: ${fn}`);
    }

    default:
      throw new Error(`Unsupported node type: ${node.type}`);
  }
}

// Safe wrapper to parse & convert a user equation into GLSL
function safeToGLSL(exprString) {
  if (!exprString.trim()) return '';
  try {
    const processedExpr = preprocess(exprString);
    const node = math.parse(processedExpr);
    return mathjsToGLSL(node);
  } catch (err) {
    console.error("GLSL conversion error:", err);
    throw new Error(`Invalid equation: ${err.message}`);
  }
}


function createShaderMaterial(equationGLSL, color) {
  return new THREE.ShaderMaterial({
    vertexShader: `
      varying vec3 vColor;
      varying vec3 vPosition;
      varying vec3 vNormal;

      float f(float x, float y) {
        return ${equationGLSL};
      }

      void main() {
        float x = position.x;
        float y = position.y;
        float z = f(x, y);
        
        // Calculate surface normal for shading
        float eps = 0.01;
        float dx = (f(x + eps, y) - f(x - eps, y)) / (2.0 * eps);
        float dy = (f(x, y + eps) - f(x, y - eps)) / (2.0 * eps);
        vec3 normal = normalize(vec3(-dx, -dy, 1.0));
        
        vPosition = vec3(x, y, z);
        vNormal = normal;
        vColor = vec3(${color.r.toFixed(2)}, ${color.g.toFixed(2)}, ${color.b.toFixed(2)});

        gl_Position = projectionMatrix * modelViewMatrix * vec4(vPosition, 1.0);
      }
    `,
    fragmentShader: `
      varying vec3 vColor;
      varying vec3 vPosition;
      varying vec3 vNormal;

      void main() {
        // Soft upper right corner light
        vec3 cornerLight = normalize(vec3(0.8, 0.6, 0.4));
        float diffuse = max(dot(vNormal, cornerLight), 0.0);
        
        // Soften the lighting transition
        diffuse = smoothstep(0.0, 1.0, diffuse);
        
        // Create lighter shadows with more subtle transitions
        vec3 shadedColor = vColor * (0.45 + 0.55 * diffuse);
        gl_FragColor = vec4(shadedColor, 1.0);
      }
    `,
    side: THREE.DoubleSide,
    wireframe: false
  });
}




    function updateEquation(index, text) {
  // Early return for empty equations
  if (!text.trim()) {
    document.getElementById('error').innerText = '';
    // Remove old mesh if it exists
    if (meshes[index]) {
      scene.remove(meshes[index]);
      meshes[index].geometry.dispose();
      meshes[index].material.dispose();
      meshes[index] = null;
    }
    return;
  }

  // Guard against deleted equations
  if (!equations[index]) {
    document.getElementById('error').innerText = '';
    return;
  }

  let equationGLSL;
  try {
    equationGLSL = (equations[index] && equations[index].glsl) || safeToGLSL(text.trim());
  } catch (err) {
    document.getElementById('error').innerText = `Invalid equation: ${err.message}`;
    return;
  }

  document.getElementById('error').innerText = '';

  // Remove old mesh if it exists
  if (meshes[index]) {
    scene.remove(meshes[index]);
    meshes[index].geometry.dispose();
    meshes[index].material.dispose();
    meshes[index] = null;
  }

  try {
    const geometry = new THREE.PlaneGeometry(range * 2, range * 2, resolution, resolution);
    const color = new THREE.Color(equations[index].color);
    const material = createShaderMaterial(equationGLSL, color); // ✅ use parsed GLSL here

    const mesh = new THREE.Mesh(geometry, material);
    meshes[index] = mesh;
    scene.add(mesh);
  } catch (e) {
    document.getElementById('error').innerText = `Error in equation ${index + 1}: ${e.message}`;
  }
}


    function addEquation(equationText = '', placeholder = 'Enter equation') {
      const container = document.getElementById('equations');
      const index = equations.length;
      equations.push({ text: equationText, color: getRandomColor() });

      const row = document.createElement('div');
      row.className = 'equation-row';

      // Create the math span
      const mathSpan = document.createElement('span');
      mathSpan.className = 'equation-input';

      // Initialize MathQuill field
      const mathField = MQ.MathField(mathSpan, {
        spaceBehavesLikeTab: true,
        handlers: {
          edit: () => {
            const rawValue = mathField.text();
            const value = rawValue.replace(/\s+/g, ''); // strip spaces
            mathSpan.classList.toggle('empty', value === '');

            // Add new row if last and not empty
            const rows = document.querySelectorAll('.equation-row');
            const isLast = row === rows[rows.length - 1];
            if (isLast && value !== '') {
              addEquation('', placeholder);
            }

            // Debounce with typing delay
            clearTimeout(typingTimer);
            typingTimer = setTimeout(() => {
              const trimmedValue = value.trim();
              // Only process if value is not empty and parentheses are balanced
              if (trimmedValue && isBalanced(trimmedValue)) {
                try {
                  const processedValue = preprocess(trimmedValue);
                  const node = math.parse(processedValue);
                  const glsl = mathjsToGLSL(node);
                  equations[index].glsl = glsl;
                  updateEquation(index, trimmedValue);
                  document.getElementById('error').innerText = ''; // Clear error on success
                } catch (err) {
                  console.error("Equation parsing error:", err);
                  document.getElementById('error').innerText = `Error: ${err.message}`;
                }
              } else if (!trimmedValue) {
                document.getElementById('error').innerText = ''; // Clear error for empty input
              }
            }, typingDelay);

          }
        }
      });

      // Set initial text if any
      if (equationText) {
        const latexText = equationText
          .replace(/sin/g, '\\sin')
          .replace(/cos/g, '\\cos')
          .replace(/tan/g, '\\tan');
        setTimeout(() => mathField.latex(latexText), 0);
      }

      // Add placeholder effect
      mathSpan.dataset.placeholder = placeholder;
      mathSpan.classList.toggle('empty', equationText.trim() === '');

      const removeBtn = document.createElement('button');
      removeBtn.className = 'remove-btn';
      removeBtn.innerHTML = '<img src="images/svg.svg" alt="Delete" width="16" height="16">';
      removeBtn.onclick = () => {
        equations[index] = null;
        if (meshes[index]) {
          scene.remove(meshes[index]);
          meshes[index].geometry.dispose();
          meshes[index].material.dispose();
          meshes[index] = null;
        }
        container.removeChild(row);
        const remainingRows = document.querySelectorAll('.equation-row').length;
        while (remainingRows < 2) {
          addEquation('', placeholder);
          break;
        }
      };

      row.appendChild(mathSpan);
      row.appendChild(removeBtn);
      container.appendChild(row);
    }

    function getRandomColor() {
      return `#${Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0')}`;
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    init();
    addEquation('sin(x) + cos(y)');
    addEquation('');
  </script>
</body>
</html>