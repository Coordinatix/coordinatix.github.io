<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Graphing Calculator</title>
    <!-- MathQuill CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css">
    <style>
        body {
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background-color: #eaedf3;
            color: #333;
        }
        #app-container {
            display: flex;
            width: 100%;
            height: 100%;
        }

    /* Sidebar Styling */
    #sidebar {
        width: 350px;
        min-width: 280px;
        background-color: #ffffff;
        box-shadow: 2px 0 10px rgba(0,0,0,0.08);
        display: flex;
        flex-direction: column;
        padding: 20px 15px;
        overflow-y: auto;
        position: relative;
        z-index: 100;
    }
    #sidebar h2 {
        position: relative;
        text-align: center;
        color: #2c3e50;
        margin: 0 0 25px;
        font-size: 1.8em;
        font-weight: 600;
        border-bottom: 1px solid #e0e0e0;
        padding-bottom: 15px;
    }
    .view-3d-btn {
        position: static;
        transform: perspective(1000px) rotateX(10deg) rotateY(-10deg);
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: linear-gradient(135deg, #e74c3c, #c0392b);
        color: white;
        border: none;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
        text-align: center;
        padding: 0;
        box-sizing: border-box;
        white-space: nowrap;
        overflow: hidden;
        box-shadow: -2px 6px 12px rgba(192, 57, 43, 0.4), inset 1px 1px 0 rgba(255,255,255,0.3), inset -1px -1px 0 rgba(0,0,0,0.2);
    }
    #equation-list {
        flex-grow: 1;
        margin: 40px 0 15px 0;
        position: relative;
        display: flex;
        flex-direction: column;
    }
    .equation-container {
        margin-bottom: 20px;
        padding: 10px 0;
        border-bottom: 1px solid #e0e0e0;
    }
    .equation-container:last-child {
        border-bottom: none;
        margin-bottom: 10px;
    }
    
    .action-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        border: none;
        cursor: pointer;
        position: absolute;
        padding: 0;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        color: transparent;
        font-size: 0;
        background-color: transparent;
    }
    
    #keyboard-toggle-btn {
        bottom: 15px;
        right: 15px;
        z-index: 1000;
        background-image: url('images/keyboard.png');
    }
    
    #reset-btn {
        top: 15px;
        left: 15px;
        z-index: 100;
        background-image: url('images/home.png');
    }
    .equation-input-group {
        display: flex;
        align-items: center;
        margin-bottom: 12px;
        background-color: #fdfdfd;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        padding: 6px 10px;
        transition: all 0.2s ease-in-out;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    .equation-input-group:focus-within {
        border-color: #3498db;
        box-shadow: 0 1px 5px rgba(52, 152, 219, 0.2);
    }
    .equation-input-group.error {
        border-color: #e74c3c;
        box-shadow: 0 1px 5px rgba(231, 76, 60, 0.2);
    }
    .equation-input-group .mq-editable-field {
        flex-grow: 1;
        font-size: 1.1em;
        padding: 2px 5px;
        border: none;
        outline: none;
        min-height: 32px;
        box-sizing: border-box;
        background-color: transparent;
        cursor: text;
    }
    .equation-input-group .color-picker {
        width: 28px;
        height: 28px;
        border: 1px solid #cfcfcf;
        border-radius: 6px;
        padding: 0;
        cursor: pointer;
        margin-right: 10px;
        background: none;
        -webkit-appearance: none;
        appearance: none;
    }
    .equation-input-group .color-picker::-webkit-color-swatch-wrapper {
        padding: 0;
    }
    .equation-input-group .color-picker::-webkit-color-swatch {
        border: none;
    }
    .equation-input-group .remove-btn {
        width: 28px;
        height: 28px;
        cursor: pointer;
        margin-left: 8px;
        padding: 0;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        border: none;
        background-color: transparent;
        background-image: url('images/svg.svg');
        background-size: 12px 12px;
        background-repeat: no-repeat;
        background-position: center;
        color: transparent;
        font-size: 0;
    }
    .sidebar-btn {
        display: block;
        width: 100%;
        background-color: #3498db;
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1em;
        font-weight: 500;
        margin-top: 10px;
        transition: background-color 0.2s, transform 0.1s;
    }
    .sidebar-btn:hover {
        background-color: #2980b9;
        transform: translateY(-1px);
    }
    .sidebar-btn:active {
        transform: translateY(0);
    }

    /* Graph Area */
    #graph-area {
        flex-grow: 1;
        position: relative;
        background-color: #ffffff;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    #graph-canvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
    }

    /* Virtual Keyboard */
    #virtual-keyboard-container {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: rgba(255,255,255,0.98);
        box-shadow: 0 -5px 20px rgba(0,0,0,0.15);
        padding: 15px;
        border-top-left-radius: 8px;
        border-top-right-radius: 15px;
        z-index: 200;
        display: none;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        max-height: 40vh;
        overflow-y: auto;
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
    }
    #virtual-keyboard-container.visible {
        display: flex;
    }
    .keyboard-btn {
        background: linear-gradient(135deg, #f0f4f7, #ffffff);
        border: 2px solid #dcdfe4;
        border-radius: 12px;
        padding: 12px 18px;
        font-size: 1.1em;
        font-weight: 500;
        cursor: pointer;
        min-width: 50px;
        text-align: center;
        transition: all 0.2s ease-in-out;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.5);
        user-select: none;
    }
    .keyboard-btn:hover {
        background: linear-gradient(135deg, #e5e9ed, #f8f9fa);
        border-color: #cdd2d9;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.5);
    }
    .keyboard-btn:active {
        background: linear-gradient(135deg, #dbe0e5, #e5e9ed);
        transform: translateY(0);
        box-shadow: 0 1px 4px rgba(0,0,0,0.08), inset 0 1px 2px rgba(0,0,0,0.1);
    }
    .keyboard-btn.op {
        background: linear-gradient(135deg, #e8f5e9, #f1f8e9);
        border-color: #c8e6c9;
        color: #2e7d32;
        box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);
    }
    .keyboard-btn.op:hover {
        background: linear-gradient(135deg, #c8e6c9, #dcedc8);
        box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
    }
    .keyboard-btn.func {
        background: linear-gradient(135deg, #e3f2fd, #f5faff);
        border-color: #bbdefb;
        color: #1976d2;
        box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
    }
    .keyboard-btn.func:hover {
        background: linear-gradient(135deg, #bbdefb, #e1f5fe);
        box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
    }
    .keyboard-btn.special {
        background: linear-gradient(135deg, #fff3e0, #fff8e1);
        border-color: #ffe0b2;
        color: #ef6c00;
        box-shadow: 0 2px 8px rgba(255, 152, 0, 0.2);
    }
    .keyboard-btn.special:hover {
        background: linear-gradient(135deg, #ffe0b2, #ffecb3);
        box-shadow: 0 4px 12px rgba(255, 152, 0, 0.3);
    }
    .keyboard-btn.clear, .keyboard-btn.backspace {
        background: linear-gradient(135deg, #ef9a9a, #ffcdd2);
        border-color: #e57373;
        color: #c62828;
        font-weight: bold;
        box-shadow: 0 2px 8px rgba(244, 67, 54, 0.2);
    }
    .keyboard-btn.clear:hover, .keyboard-btn.backspace:hover {
        background: linear-gradient(135deg, #e57373, #ef9a9a);
        box-shadow: 0 4px 12px rgba(244, 67, 54, 0.3);
    }
    .keyboard-btn.enter {
        background: linear-gradient(135deg, #a5d6a7, #c8e6c9);
        border-color: #81c784;
        color: #388e3c;
        font-weight: bold;
        box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
    }
    .keyboard-btn.enter:hover {
        background: linear-gradient(135deg, #81c784, #a5d6a7);
        box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }
    .keyboard-btn.wide {
        flex-basis: calc(33.33% - 10px);
        max-width: 150px;
    }

    /* Mobile Responsiveness */
    @media (max-width: 768px) {
        #app-container {
            flex-direction: column;
        }
        #sidebar {
            width: 100%;
            min-width: unset;
            padding: 10px;
            height: auto;
            flex-shrink: 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            position: relative;
        }
        #sidebar h2 {
            font-size: 1.5em;
            margin-bottom: 15px;
            padding-bottom: 10px;
        }
        #equation-list {
            flex-grow: unset;
            position: relative;
            padding-top: 60px;
            max-height: 140px;
            overflow-y: auto;
            margin-bottom: 10px;
        }
        .equation-input-group {
            padding: 12px 15px;
            margin-bottom: 15px;
            min-height: 50px;
            align-items: stretch;
        }
        .equation-input-group .mq-editable-field {
            flex-grow: 1;
            font-size: 1.3em;
            padding: 5px 10px;
            min-height: 45px;
        }
        .equation-input-group .color-picker {
            width: 40px;
            height: 40px;
            margin-right: 15px;
        }
        .equation-input-group .remove-btn {
            width: 36px;
            height: 36px;
            margin-left: 15px;
            padding: 0 10px;
            min-width: 36px;
            background-size: 16px 16px;
        }
        .view-3d-btn {
            width: 50px;
            height: 50px;
            font-size: 18px;
            right: 10px;
        }
        #graph-area {
            flex-grow: 1;
            height: auto;
            min-height: 50vh;
            position: relative;
        }
        #virtual-keyboard-container {
            padding: 10px;
            gap: 8px;
            max-height: 35vh;
        }
        .keyboard-btn {
            padding: 15px 20px;
            font-size: 1.2em;
            min-width: 60px;
            min-height: 50px;
            border-radius: 14px;
        }
        .keyboard-btn.wide {
            flex-basis: calc(50% - 8px);
            max-width: none;
        }
        body {
            font-size: 16px; /* Ensure base font size for mobile */
        }
        /* Mobile button positions */
        #keyboard-toggle-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 52px;
            height: 52px;
            padding: 0;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 150;
            margin: 0;
            background-size: 24px 24px;
        }
        #reset-btn.mobile {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 52px;
            height: 52px;
            padding: 0;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            z-index: 100;
            background-size: 24px 24px;
        }
        .action-btn {
            width: 52px;
            height: 52px;
            font-size: 24px;
            background-size: 24px 24px;
        }
    }

    @media (max-width: 480px) {
        .keyboard-btn {
            padding: 12px 15px;
            font-size: 1.1em;
            min-width: 55px;
            min-height: 45px;
        }
        .keyboard-btn.wide {
            flex-basis: 100%;
        }
        #equation-list {
            max-height: 120px;
        }
        .action-btn {
            width: 48px;
            height: 48px;
            font-size: 20px;
            background-size: 20px 20px;
        }
        #keyboard-toggle-btn, #reset-btn.mobile {
            width: 48px;
            height: 48px;
            font-size: 20px;
            background-size: 20px 20px;
        }
    }
</style></head>
<body>
    <div id="app-container">
        <div id="sidebar">
            <div style="display: flex; align-items: center; justify-content: space-between; gap: 1px;">
                <img src="images/logo.jpg" alt="Logo" style="height: 130px; width: auto;">
                <button id="view-3d-btn" class="view-3d-btn">3D</button>
            </div>
            <div id="equation-list"></div>
        </div>
        <div id="graph-area">
            <canvas id="graph-canvas"></canvas>
            <button id="reset-btn" class="action-btn" title="Reset View" aria-label="Reset View"></button>
            <button id="keyboard-toggle-btn" class="action-btn" title="Toggle Keyboard" aria-label="Toggle Keyboard"></button>
            <div id="virtual-keyboard-container"></div>
        </div>
    </div>

<!-- jQuery (MathQuill dependency) -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
<!-- MathQuill JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js"></script>
<!-- Evaluatex for LaTeX parsing and safe evaluation -->
<script src="https://cdn.jsdelivr.net/npm/evaluatex@2.2.0/dist/evaluatex.min.js"></script>

<script>
    // Graph2D Class
    class Graph2D {
        constructor(canvas, options = {}) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.dpr = window.devicePixelRatio || 1;

            this.style = {
                bg: options.bg || '#ffffff',
                gridMajor: options.gridMajor || '#999999',
                gridMinor: options.gridMinor || '#e5e5e5',
                axis: options.axis || '#333333',
                axisArrow: options.axisArrow || '#333333',
                tick: options.tick || '#666666',
                text: options.text || '#222222',
                crosshair: options.crosshair || 'rgba(0,0,0,0.25)',
                tooltipBg: options.tooltipBg || 'rgba(255,255,255,0.9)',
                tooltipBorder: options.tooltipBorder || 'rgba(0,0,0,0.15)',
                legendText: options.legendText || '#111111'
            };

            this.originX = options.originX ?? 0;
            this.originY = options.originY ?? 0;
            this.scaleX = options.scaleX ?? 60;
            this.scaleY = options.scaleY ?? 60;
            this.minScale = options.minScale ?? 10;
            this.maxScale = options.maxScale ?? 1000;
            this.isDragging = false;
            this.isPinching = false;
            this.dragStart = { sx: 0, sy: 0, ox: 0, oy: 0 };
            this.mouse = { sx: 0, sy: 0, x: 0, y: 0, inside: false };
            this.inertia = { vx: 0, vy: 0, active: false };
            this.lastTouchDist = 0;
            this.zoomFactorPerWheel = options.zoomFactorPerWheel ?? 1.08;
            this.enableInertia = options.enableInertia ?? true;
            this.series = [];
            this.legend = { show: false, position: 'top-right' };
            this.tooltip = { show: true, padding: 8, font: '12px sans-serif' };
            this.needsRedraw = true;
            this.anim = null;
            this._initialOriginSet = false;

            // Double-tap support
            this.lastTapTime = 0;
            this.tapThreshold = 10;
            this.tapDuration = 250;
            this.doubleTapDuration = 300;
            this.tapStart = null;
            this.dragged = false;

            this.resizeObserver = new ResizeObserver(() => this.resize());
            this.resizeObserver.observe(this.canvas);
            this.attachEvents();
            this.loop();
        }

        worldToScreen(x, y) {
            return {
                sx: (x - this.originX) * this.scaleX,
                sy: (this.originY - y) * this.scaleY
            };
        }

        screenToWorld(sx, sy) {
            return {
                x: sx / this.scaleX + this.originX,
                y: this.originY - sy / this.scaleY
            };
        }

        addFunction(fn, options = {}) {
            const s = {
                type: 'function',
                fn,
                color: options.color || '#2a62ff',
                width: options.width || 2,
                sampleStep: options.sampleStep || 1,
                name: options.name || 'f(x)'
            };
            this.series.push(s);
            this.requestRedraw();
            return s;
        }

        clearSeries() {
            this.series = [];
            this.requestRedraw();
        }

        resize() {
            const rect = this.canvas.getBoundingClientRect();
            const logicalW = rect.width;
            const logicalH = rect.height;
            this.canvas.width = Math.round(logicalW * this.dpr);
            this.canvas.height = Math.round(logicalH * this.dpr);
            this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);

            if (!this._initialOriginSet) {
                this.originX = - (logicalW / 2) / this.scaleX;
                this.originY = (logicalH / 2) / this.scaleY;
                this._initialOriginSet = true;
            }

            this.requestRedraw();
        }

        attachEvents() {
            const c = this.canvas;

            // Mouse events
            c.addEventListener('mousedown', (e) => {
                this.isDragging = true;
                this.isPinching = false;
                this.inertia.active = false;
                const rect = c.getBoundingClientRect();
                const sx = e.clientX - rect.left;
                const sy = e.clientY - rect.top;
                this.dragStart = { sx, sy, ox: this.originX, oy: this.originY };
            });

            window.addEventListener('mousemove', (e) => {
                const rect = c.getBoundingClientRect();
                const sx = e.clientX - rect.left;
                const sy = e.clientY - rect.top;
                this.mouse.sx = sx;
                this.mouse.sy = sy;
                const w = this.screenToWorld(sx, sy);
                this.mouse.x = w.x;
                this.mouse.y = w.y;
                this.mouse.inside =
                    e.clientX >= rect.left &&
                    e.clientX <= rect.right &&
                    e.clientY >= rect.top &&
                    e.clientY <= rect.bottom;

                if (this.isDragging) {
                    const dx = sx - this.dragStart.sx;
                    const dy = sy - this.dragStart.sy;
                    const prevOriginX = this.originX;
                    const prevOriginY = this.originY;
                    this.originX = this.dragStart.ox - dx / this.scaleX;
                    this.originY = this.dragStart.oy + dy / this.scaleY;
                    this.inertia.vx = (this.originX - prevOriginX);
                    this.inertia.vy = (this.originY - prevOriginY);
                    this.requestRedraw();
                }
            });

            window.addEventListener('mouseup', () => {
                if (this.isDragging && this.enableInertia) {
                    this.inertia.active = true;
                }
                this.isDragging = false;
            });

            c.addEventListener('mouseleave', () => {
                this.mouse.inside = false;
                this.requestRedraw();
            });

            c.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = c.getBoundingClientRect();
                const sx = e.clientX - rect.left;
                const sy = e.clientY - rect.top;
                const { x: wx, y: wy } = this.screenToWorld(sx, sy);
                const dir = Math.sign(e.deltaY);
                const factor = Math.pow(this.zoomFactorPerWheel, dir);
                const newScaleX = this.clamp(this.scaleX / factor, this.minScale, this.maxScale);
                const newScaleY = this.clamp(this.scaleY / factor, this.minScale, this.maxScale);
                this.originX = wx - sx / newScaleX;
                this.originY = wy + sy / newScaleY;
                this.scaleX = newScaleX;
                this.scaleY = newScaleY;
                this.inertia.active = false;
                this.requestRedraw();
            }, { passive: false });

            c.addEventListener('dblclick', () => {
                this.resetView();
            });

            // Touch events
            c.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const rect = c.getBoundingClientRect();
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    const sx = touch.clientX - rect.left;
                    const sy = touch.clientY - rect.top;
                    this.tapStart = { sx, sy, time: Date.now() };
                    this.dragged = false;
                    this.dragStart = { sx, sy, ox: this.originX, oy: this.originY };
                    this.mouse.sx = sx;
                    this.mouse.sy = sy;
                    const w = this.screenToWorld(sx, sy);
                    this.mouse.x = w.x;
                    this.mouse.y = w.y;
                    this.mouse.inside = true;
                    this.isDragging = true;
                    this.isPinching = false;
                    this.inertia.active = false;
                } else if (e.touches.length === 2) {
                    this.tapStart = null;
                    this.dragged = false;
                    this.isPinching = true;
                    this.isDragging = false;
                    const t1 = e.touches[0], t2 = e.touches[1];
                    const sx1 = t1.clientX - rect.left;
                    const sy1 = t1.clientY - rect.top;
                    const sx2 = t2.clientX - rect.left;
                    const sy2 = t2.clientY - rect.top;
                    this.lastTouchDist = Math.hypot(sx1 - sx2, sy1 - sy2);
                    this.mouse.sx = (sx1 + sx2) / 2;
                    this.mouse.sy = (sy1 + sy2) / 2;
                    const w = this.screenToWorld(this.mouse.sx, this.mouse.sy);
                    this.mouse.x = w.x;
                    this.mouse.y = w.y;
                    this.mouse.inside = true;
                }
            }, { passive: false });

            c.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const rect = c.getBoundingClientRect();
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    const sx = touch.clientX - rect.left;
                    const sy = touch.clientY - rect.top;
                    this.mouse.sx = sx;
                    this.mouse.sy = sy;
                    const w = this.screenToWorld(this.mouse.sx, this.mouse.sy);
                    this.mouse.x = w.x;
                    this.mouse.y = w.y;
                    this.mouse.inside = true;

                    if (this.tapStart && !this.dragged) {
                        const dist = Math.hypot(sx - this.tapStart.sx, sy - this.tapStart.sy);
                        if (dist > this.tapThreshold) {
                            this.dragged = true;
                        }
                    }

                    if (this.isDragging) {
                        const dx = sx - this.dragStart.sx;
                        const dy = sy - this.dragStart.sy;
                        const prevOriginX = this.originX;
                        const prevOriginY = this.originY;
                        this.originX = this.dragStart.ox - dx / this.scaleX;
                        this.originY = this.dragStart.oy + dy / this.scaleY;
                        this.inertia.vx = (this.originX - prevOriginX);
                        this.inertia.vy = (this.originY - prevOriginY);
                        this.requestRedraw();
                    }
                } else if (this.isPinching && e.touches.length === 2) {
                    const t1 = e.touches[0], t2 = e.touches[1];
                    const sx1 = t1.clientX - rect.left;
                    const sy1 = t1.clientY - rect.top;
                    const sx2 = t2.clientX - rect.left;
                    const sy2 = t2.clientY - rect.top;
                    const dist = Math.hypot(sx1 - sx2, sy1 - sy2);
                    if (this.lastTouchDist > 0) {
                        const factor = dist / this.lastTouchDist;
                        const centerSx = (sx1 + sx2) / 2;
                        const centerSy = (sy1 + sy2) / 2;
                        const wx = centerSx / this.scaleX + this.originX;
                        const wy = this.originY - centerSy / this.scaleY;
                        const newScaleX = this.clamp(this.scaleX * factor, this.minScale, this.maxScale);
                        const newScaleY = this.clamp(this.scaleY * factor, this.minScale, this.maxScale);
                        this.scaleX = newScaleX;
                        this.scaleY = newScaleY;
                        this.originX = wx - centerSx / newScaleX;
                        this.originY = wy + centerSy / newScaleY;
                        this.requestRedraw();
                    }
                    this.lastTouchDist = dist;
                }
            }, { passive: false });

            c.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (e.touches.length === 0) {
                    if (this.enableInertia && this.dragged) {
                        this.inertia.active = true;
                    }
                    this.isDragging = false;
                    this.isPinching = false;
                    this.lastTouchDist = 0;

                    // Double-tap detection
                    if (this.tapStart && !this.dragged && (Date.now() - this.tapStart.time < this.tapDuration)) {
                        const now = Date.now();
                        if (now - this.lastTapTime < this.doubleTapDuration) {
                            this.resetView();
                        }
                        this.lastTapTime = now;
                    }
                    this.tapStart = null;
                    this.dragged = false;
                }
            }, { passive: false });
        }

        resetView() {
            this.scaleX = 60;
            this.scaleY = 60;
            const rect = this.canvas.getBoundingClientRect();
            this.originX = - (rect.width / 2) / this.scaleX;
            this.originY = (rect.height / 2) / this.scaleY;
            this.inertia.active = false;
            this.requestRedraw();
        }

        clamp(v, a, b) {
            return Math.max(a, Math.min(b, v));
        }

        requestRedraw() {
            this.needsRedraw = true;
        }

        loop() {
            const tick = () => {
                if (this.inertia.active && !this.isDragging && !this.isPinching) {
                    this.originX += this.inertia.vx;
                    this.originY += this.inertia.vy;
                    this.inertia.vx *= 0.9;
                    this.inertia.vy *= 0.9;
                    if (Math.abs(this.inertia.vx) < 1e-4 && Math.abs(this.inertia.vy) < 1e-4) {
                        this.inertia.active = false;
                    }
                    this.needsRedraw = true;
                }

                if (this.needsRedraw) {
                    this.render();
                    this.needsRedraw = false;
                }
                this.anim = requestAnimationFrame(tick);
            };
            this.anim = requestAnimationFrame(tick);
        }

        niceStep(pixelTarget = 80, scalePxPerUnit = 60) {
            const raw = pixelTarget / scalePxPerUnit;
            const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
            const candidates = [1, 2, 5].map(m => m * pow10);
            let best = candidates[0];
            let bd = Math.abs(candidates[0] - raw);
            for (let i = 1; i < candidates.length; i++) {
                const d = Math.abs(candidates[i] - raw);
                if (d < bd) { bd = d; best = candidates[i]; }
            }
            return best;
        }

        render() {
            const ctx = this.ctx;
            const w = this.canvas.clientWidth;
            const h = this.canvas.clientHeight;

            ctx.save();
            ctx.fillStyle = this.style.bg;
            ctx.fillRect(0, 0, w, h);

            this.drawGrid(w, h);
            this.drawAxes(w, h);

            for (const s of this.series) {
                if (s.type === 'function') this.drawFunctionSeries(s, w, h);
            }

            if (this.mouse.inside) {
                this.drawCrosshair(w, h);
                if (this.tooltip.show) this.drawTooltip();
            }

            ctx.restore();
        }

        drawGrid(w, h) {
            const ctx = this.ctx;
            const xStep = this.niceStep(80, this.scaleX);
            const yStep = this.niceStep(80, this.scaleY);
            const xMinor = xStep / 5;
            const yMinor = yStep / 5;
            const xMin = this.screenToWorld(0, 0).x;
            const xMax = this.screenToWorld(w, 0).x;
            const yMin = this.screenToWorld(0, h).y;
            const yMax = this.screenToWorld(0, 0).y;

            ctx.lineWidth = 1;
            ctx.strokeStyle = this.style.gridMinor;

            let xStartMinor = Math.floor(xMin / xMinor) * xMinor;
            for (let x = xStartMinor; x <= xMax; x += xMinor) {
                if (Math.abs(x) < 1e-9) continue;
                const { sx } = this.worldToScreen(x, 0);
                if (sx >= 0 && sx <= w) {
                    ctx.beginPath();
                    ctx.moveTo(sx, 0);
                    ctx.lineTo(sx, h);
                    ctx.stroke();
                }
            }

            let yStartMinor = Math.floor(yMin / yMinor) * yMinor;
            for (let y = yStartMinor; y <= yMax; y += yMinor) {
                if (Math.abs(y) < 1e-9) continue;
                const { sy } = this.worldToScreen(0, y);
                if (sy >= 0 && sy <= h) {
                    ctx.beginPath();
                    ctx.moveTo(0, sy);
                    ctx.lineTo(w, sy);
                    ctx.stroke();
                }
            }

            ctx.strokeStyle = this.style.gridMajor;
            let xStart = Math.floor(xMin / xStep) * xStep;
            for (let x = xStart; x <= xMax; x += xStep) {
                if (Math.abs(x) < 1e-9) continue;
                const { sx } = this.worldToScreen(x, 0);
                if (sx >= 0 && sx <= w) {
                    ctx.beginPath();
                    ctx.moveTo(sx, 0);
                    ctx.lineTo(sx, h);
                    ctx.stroke();

                    const label = this.formatTick(x);
                    ctx.fillStyle = this.style.text;
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    const axisY = this.worldToScreen(0, 0).sy;
                    const labelY = axisY < h - 18 ? (axisY > 5 ? axisY + 10 : 5) : h - 18;
                    ctx.textBaseline = 'top';
                    ctx.fillText(label, sx, labelY);
                }
            }

            let yStart = Math.floor(yMin / yStep) * yStep;
            for (let y = yStart; y <= yMax; y += yStep) {
                if (Math.abs(y) < 1e-9) continue;
                const { sy } = this.worldToScreen(0, y);
                if (sy >= 0 && sy <= h) {
                    ctx.beginPath();
                    ctx.moveTo(0, sy);
                    ctx.lineTo(w, sy);
                    ctx.stroke();

                    const label = this.formatTick(y);
                    ctx.fillStyle = this.style.text;
                    ctx.font = '12px sans-serif';
                    const axisX = this.worldToScreen(0, 0).sx;
                    const labelX = axisX > 40 ? (axisX < w - 5 ? axisX - 10 : w - 5) : 40;
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(label, labelX, sy);
                }
            }
        }

        formatTick(v) {
            if (v === 0) return '0';
            const mag = Math.max(Math.abs(v), 1e-12);
            const logScale = Math.log10(Math.max(this.scaleX, this.scaleY));
            let precision = logScale > 2 ? 3 : logScale > 1 ? 2 : logScale > 0 ? 1 : 0;

            if (mag >= 1e5 || mag < 1e-4) {
                return v.toExponential(1);
            }
            if (Math.abs(v - Math.round(v)) < 1e-6) {
                return Math.round(v).toString();
            }
            if (Math.abs(v * 10 - Math.round(v * 10)) < 1e-6) {
                return (Math.round(v * 10) / 10).toFixed(1);
            }
            return v.toFixed(precision);
        }

        drawAxes(w, h) {
            const ctx = this.ctx;
            ctx.strokeStyle = this.style.axis;
            ctx.lineWidth = 1.5;

            const y0 = this.worldToScreen(0, 0).sy;
            ctx.beginPath();
            ctx.moveTo(0, y0);
            ctx.lineTo(w, y0);
            ctx.stroke();

            const x0 = this.worldToScreen(0, 0).sx;
            ctx.beginPath();
            ctx.moveTo(x0, 0);
            ctx.lineTo(x0, h);
            ctx.stroke();

            ctx.fillStyle = this.style.axisArrow;
            if (w - 12 > 0) this.drawArrow(w - 12, y0, w, y0);
            if (12 < h) this.drawArrow(x0, 12, x0, 0);

            ctx.fillStyle = this.style.text;
            ctx.font = '13px sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            const xLabelY = Math.min(h - 8, Math.max(15, y0 - 6));
            ctx.fillText('X', w - 8, xLabelY);

            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            const yLabelX = Math.min(w - 15, Math.max(6, x0 + 6));
            ctx.fillText('Y', yLabelX, 6);
        }

        drawArrow(x1, y1, x2, y2) {
            const ctx = this.ctx;
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const len = 10;
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - len * Math.cos(angle - Math.PI / 6),
                       y2 - len * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - len * Math.cos(angle + Math.PI / 6),
                       y2 - len * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        drawFunctionSeries(s, w, h) {
            const ctx = this.ctx;
            ctx.strokeStyle = s.color;
            ctx.lineWidth = s.width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();

            let started = false;
            let prevSy;

            for (let sx = 0; sx <= w; sx += s.sampleStep) {
                const { x } = this.screenToWorld(sx, 0);
                let y;
                try {
                    y = s.fn(x);
                    if (!isFinite(y)) {
                        started = false;
                        continue;
                    }
                } catch {
                    started = false;
                    continue;
                }
                const { sy } = this.worldToScreen(0, y);

                if (sy < -h || sy > 2 * h) {
                    if (started && prevSy !== undefined && (prevSy < -h || prevSy > 2 * h || Math.abs(sy - prevSy) > h * 2)) {
                        started = false;
                    } else if (!started) {
                        prevSy = sy;
                        continue;
                    }
                }

                if (!started) {
                    ctx.moveTo(sx, sy);
                    started = true;
                } else {
                    ctx.lineTo(sx, sy);
                }
                prevSy = sy;
            }
            ctx.stroke();
        }

        drawCrosshair(w, h) {
            const ctx = this.ctx;
            const sx = this.mouse.sx;
            const sy = this.mouse.sy;
            ctx.strokeStyle = this.style.crosshair;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(sx, 0);
            ctx.lineTo(sx, h);
            ctx.moveTo(0, sy);
            ctx.lineTo(w, sy);
            ctx.stroke();
        }

        drawTooltip() {
            const ctx = this.ctx;
            const { sx, sy, x, y } = this.mouse;
            const text = `(${this.formatTick(x)}, ${this.formatTick(y)})`;

            ctx.font = this.tooltip.font;
            const metrics = ctx.measureText(text);
            const padding = this.tooltip.padding;
            const tw = metrics.width + padding * 2;
            const th = 20 + padding * 2;
            let bx = sx + 12, by = sy + 12;

            const cw = this.canvas.clientWidth, ch = this.canvas.clientHeight;
            if (bx + tw + 8 > cw) bx = cw - tw - 8;
            if (by + th + 8 > ch) by = ch - th - 8;
            if (bx < 8) bx = 8;
            if (by < 8) by = 8;

            ctx.fillStyle = this.style.tooltipBg;
            ctx.strokeStyle = this.style.tooltipBorder;
            ctx.beginPath();
            ctx.roundRect(bx, by, tw, th, 5);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = this.style.text;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, bx + padding, by + th / 2);
        }
    }

    // Global Variables and UI Logic
    let graph;
    let equations = [];
    let activeMathField = null;
    const equationColors = ['#2a62ff', '#e43d2f', '#008b57', '#7a3cff', '#FF8C00', '#17a2b8', '#8A2BE2', '#DC143C'];
    let colorIndex = 0;
    const MQ = MathQuill.getInterface(2);
    let inInit = true;

    function getNextColor() {
        const color = equationColors[colorIndex % equationColors.length];
        colorIndex++;
        return color;
    }

    function addEquationInput(initialLatex = 'y=', color = getNextColor(), parentDiv = document.getElementById('equation-list')) {
        const id = Date.now() + Math.random();
        const containerDiv = document.createElement('div');
        containerDiv.className = 'equation-container';

        const groupDiv = document.createElement('div');
        groupDiv.className = 'equation-input-group';
        groupDiv.dataset.id = id;

        const colorInput = document.createElement('input');
        colorInput.type = 'color';
        colorInput.className = 'color-picker';
        colorInput.value = color;

        const mqSpan = document.createElement('span');
        mqSpan.className = 'mq-editable-field mq-math-mode';

        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-btn';
        removeBtn.title = 'Remove equation';

        groupDiv.append(colorInput, mqSpan, removeBtn);
        containerDiv.appendChild(groupDiv);
        parentDiv.appendChild(containerDiv);

        const mathField = MQ.MathField(mqSpan, {
            spaceBehavesLikeTab: true,
            handlers: {
                edit: () => {
                    updateEquation(id);
                    // Check if this was the extra empty box and add new if content added
                    if (initialLatex === 'y=' && mathField.latex().trim() !== 'y=' && mathField.latex().trim() !== '') {
                        addNewEmptyInput();
                    }
                },
                focus: () => {
                    activeMathField = mathField;
                    groupDiv.classList.add('focused');
                },
                blur: () => {
                    groupDiv.classList.remove('focused');
                }
            }
        });

        mathField.latex(initialLatex);

        const equationObj = { id, mathField, color, fn: null, mqEl: groupDiv, containerEl: containerDiv, colorInputEl: colorInput, seriesRef: null, expr: '', wasEmpty: initialLatex === 'y=' };
        equations.push(equationObj);

        colorInput.addEventListener('input', (e) => {
            equationObj.color = e.target.value;
            if (equationObj.seriesRef) {
                equationObj.seriesRef.color = equationObj.color;
                graph.requestRedraw();
            }
        });

        removeBtn.addEventListener('click', () => removeEquation(id));

        updateEquation(id);

        // Ensure always one extra empty after init
        if (inInit) {
            addNewEmptyInput();
        }

        // Handle scrollable after 2 equations on mobile
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        if (isMobile && equations.length > 2) {
            document.getElementById('equation-list').style.overflowY = 'auto';
        }
    }

    function addNewEmptyInput() {
        // Only add if there's no existing extra empty one
        const hasEmpty = equations.some(eq => eq.wasEmpty && eq.mathField.latex().trim() === 'y=');
        if (!hasEmpty) {
            addEquationInput('y=', getNextColor());
        }
    }

    function updateEquation(id) {
        const eq = equations.find(e => e.id === id);
        if (!eq) return;

        const wasEmpty = !eq.fn && eq.mathField.latex().trim() === 'y=';
        const latex = eq.mathField.latex();
        let parsedFn = null;
        let error = false;

        if (eq.seriesRef) {
            graph.series = graph.series.filter(s => s !== eq.seriesRef);
            eq.seriesRef = null;
        }

        if (latex && latex.trim() !== 'y=' && latex.trim() !== '') {
            try {
                // Remove 'y=' prefix for evaluation
                const expr = latex.replace(/^(y=)/, '');
                eq.expr = expr;
                // Compile with evaluatex, enabling LaTeX mode
                const compiledFn = evaluatex(expr, {}, { latex: true });
                // Test compilation
                compiledFn({ x: 0 });
                compiledFn({ x: 1 });

                parsedFn = (xVal) => {
                    try {
                        return compiledFn({ x: xVal });
                    } catch {
                        return NaN;
                    }
                };
            } catch (e) {
                console.warn('Error parsing equation:', e);
                eq.mqEl.classList.add('error');
                error = true;
            }
        }

        if (!error && parsedFn) {
            eq.fn = parsedFn;
            eq.seriesRef = graph.addFunction(parsedFn, {
                color: eq.color,
                width: 2,
                sampleStep: 1,
                name: latex
            });
            eq.mqEl.classList.remove('error');
            eq.wasEmpty = false;
        } else {
            eq.fn = null;
            if (latex.trim() === 'y=') {
                eq.wasEmpty = true;
            }
        }
        graph.requestRedraw();
    }

    function removeEquation(id) {
        const eqIndex = equations.findIndex(e => e.id === id);
        if (eqIndex === -1) return;

        const eq = equations[eqIndex];
        if (equations.length <= 1) {
            // If last one, just clear it but keep the input
            eq.mathField.latex('y=');
            eq.wasEmpty = true;
            eq.fn = null;
            if (eq.seriesRef) {
                graph.series = graph.series.filter(s => s !== eq.seriesRef);
                eq.seriesRef = null;
            }
            graph.requestRedraw();
            return;
        }

        if (eq.seriesRef) {
            graph.series = graph.series.filter(s => s !== eq.seriesRef);
        }
        eq.containerEl.remove();
        equations.splice(eqIndex, 1);
        graph.requestRedraw();
        if (activeMathField === eq.mathField) {
            activeMathField = null;
        }

        // After removal, ensure there's always one extra empty
        setTimeout(() => addNewEmptyInput(), 0);
    }

    // Virtual Keyboard
    const virtualKeyboardContainer = document.getElementById('virtual-keyboard-container');
    const keyboardToggleBtn = document.getElementById('keyboard-toggle-btn');
    let isKeyboardVisible = false;

    const keyboardLayout = [
        [{ label: '1', latex: '1' }, { label: '2', latex: '2' }, { label: '3', latex: '3' }, { label: '+', latex: '+', className: 'op' }, { label: '−', latex: '-', className: 'op' }],
        [{ label: '4', latex: '4' }, { label: '5', latex: '5' }, { label: '6', latex: '6' }, { label: '×', latex: '\\times', className: 'op' }, { label: '÷', latex: '\\div', className: 'op' }],
        [{ label: '7', latex: '7' }, { label: '8', latex: '8' }, { label: '9', latex: '9' }, { label: 'x', latex: 'x' }, { label: '^', latex: '^', className: 'op' }],
        [{ label: '.', latex: '.' }, { label: '0', latex: '0' }, { label: '(', latex: '(', className: 'op' }, { label: ')', latex: ')', className: 'op' }, { label: 'π', latex: '\\pi', className: 'special' }],
        [{ label: 'e', latex: 'e', className: 'special' }, { label: 'sin', latex: '\\sin(', className: 'func' }, { label: 'cos', latex: '\\cos(', className: 'func' }, { label: 'tan', latex: '\\tan(', className: 'func' }, { label: '|x|', latex: '\\abs{', className: 'func' }],
        [{ label: 'ln', latex: '\\ln(', className: 'func' }, { label: 'log', latex: '\\log(', className: 'func' }, { label: '√', latex: '\\sqrt{', className: 'func' }, { label: 'frac', latex: '\\frac{', className: 'func' }, { label: 'Back', latex: 'Backspace', className: 'backspace' }],
        [{ label: 'Clear', latex: 'Clear', className: 'clear wide' }, { label: 'Enter', latex: 'Enter', className: 'enter wide' }]
    ];

    function createKeyboardButton(btnDef) {
        const btn = document.createElement('button');
        btn.className = `keyboard-btn ${btnDef.className || ''}`;
        btn.innerHTML = btnDef.label;
        btn.dataset.latex = btnDef.latex;

        btn.addEventListener('click', (e) => {
            e.preventDefault();
            if (activeMathField) {
                const ltx = btn.dataset.latex;
                if (ltx === 'Clear') {
                    activeMathField.latex('');
                } else if (ltx === 'Backspace') {
                    activeMathField.keystroke('Backspace');
                } else if (ltx === 'Enter') {
                    activeMathField.blur();
                    virtualKeyboardContainer.classList.remove('visible');
                    isKeyboardVisible = false;
                    keyboardToggleBtn.textContent = '';
                } else if (ltx === '\\sqrt{' || ltx === '\\abs{') {
                    activeMathField.cmd(ltx);
                } else if (ltx === '\\frac{') {
                    activeMathField.cmd(ltx);
                    activeMathField.keystroke('Left');
                } else if (ltx.endsWith('(') && ltx.length > 1) {
                    activeMathField.cmd(ltx.slice(0, -1));
                    activeMathField.write('(');
                    activeMathField.keystroke('Left');
                } else {
                    activeMathField.write(ltx);
                }
                activeMathField.focus();
            }
        });
        return btn;
    }

    function populateVirtualKeyboard() {
        virtualKeyboardContainer.innerHTML = '';
        keyboardLayout.forEach(row => {
            row.forEach(btnDef => {
                virtualKeyboardContainer.appendChild(createKeyboardButton(btnDef));
            });
        });
    }

    keyboardToggleBtn.addEventListener('click', () => {
        isKeyboardVisible = !isKeyboardVisible;
        virtualKeyboardContainer.classList.toggle('visible', isKeyboardVisible);
        if (isKeyboardVisible && equations.length > 0 && !activeMathField) {
            equations[0].mathField.focus();
        }
    });

    // 3D Button
    document.getElementById('view-3d-btn').addEventListener('click', () => {
        window.location.href = 'testing1.html';
    });

    // Initialization
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('graph-canvas');
        if (!canvas) {
            console.error("Canvas element with ID 'graph-canvas' not found.");
            return;
        }

        graph = new Graph2D(canvas, {
            gridMajor: '#999999',
            gridMinor: '#e5e5e5',
            scaleX: 60, scaleY: 60, enableInertia: true
        });

        // Add initial example equations
        addEquationInput('y=\\sin(x)', equationColors[0]);

        inInit = false;

        document.getElementById('reset-btn').addEventListener('click', () => {
            graph.resetView();
        });

        populateVirtualKeyboard();
        graph.resize();

        // Handle mobile layout for reset button
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        if (isMobile) {
            const graphArea = document.getElementById('graph-area');
            const resetBtn = document.getElementById('reset-btn');
            graphArea.appendChild(resetBtn);
            resetBtn.classList.add('mobile');
        }
    });
</script></body>
</html>