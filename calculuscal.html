<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Calculus Lab — Integrate, Differentiate, Limits</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <!-- MathQuill dependencies -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js"></script>
  <!-- KaTeX for math rendering -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <!-- Math.js for parsing and symbolic derivative -->
  <script src="https://cdn.jsdelivr.net/npm/mathjs@12.4.1/lib/browser/math.js"></script>
  <!-- Plotly for graphing -->
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

  <style>
    :root {
      --bg0: #0B1020;
      --bg1: #0E1530;
      --bg2: #162042;
      --glass: rgba(255, 255, 255, 0.08);
      --glass2: rgba(255, 255, 255, 0.12);
      --border: rgba(255, 255, 255, 0.18);
      --text: #e6e9f0;
      --muted: #9ba3b0;
      --accent: #7C5CFF;
      --accent2: #00D4FF;
      --danger: #ff5c7c;
      --success: #33d69f;
      --shadow: 0 30px 60px rgba(0,0,0,0.35);
      --shadow-sm: 0 8px 24px rgba(0,0,0,0.25);
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 600px at 15% 0%, #0f1c44 0%, var(--bg1) 40%, var(--bg0) 100%),
                  conic-gradient(from 220deg at 80% 30%, #0f1b36, #0b1020);
      overflow-x: hidden;
    }
    .aurora {
      position: fixed;
      inset: 0;
      pointer-events: none;
      filter: blur(60px);
      opacity: 0.35;
      z-index: -1;
    }
    .blob {
      position: absolute;
      width: 40vw; height: 40vw;
      background: radial-gradient(circle at 30% 30%, rgba(124,92,255,0.25), transparent 60%);
      border-radius: 50%;
      transform: translate(-10%, -10%);
      animation: float 18s infinite ease-in-out;
    }
    .blob2 {
      position: absolute;
      width: 45vw; height: 45vw;
      background: radial-gradient(circle at 70% 50%, rgba(0,212,255,0.25), transparent 70%);
      border-radius: 50%;
      right: -10%; bottom: -15%;
      animation: float 24s infinite ease-in-out reverse;
    }
    @keyframes float {
      0%, 100% { transform: translate(0, 0); }
      25% { transform: translate(2%, 2%); }
      50% { transform: translate(-1%, 3%); }
      75% { transform: translate(1%, -2%); }
    }header {
  max-width: 1100px;
  margin: 40px auto 20px;
  padding: 0 24px;
  display: flex;
  align-items: center;
  gap: 24px;
  position: relative;
}

header > .chip {
  width: max-content;
  flex: 0 0 auto;
}
.brand {
  display: flex; align-items: center; gap: 16px;
  position: relative;
  flex: 1;
}
.logo {
  width: 48px; height: 48px;
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  border-radius: 14px;
  box-shadow: 0 10px 28px rgba(124, 92, 255, 0.35), 
              inset 0 0 24px rgba(255,255,255,0.25);
  position: relative;
  transition: transform 0.3s ease;
  flex-shrink: 0;
}
.logo:hover {
  transform: translateY(-2px) scale(1.02);
}
.logo::after {
  content: "";
  position: absolute;
  inset: -1px;
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  border-radius: inherit;
  opacity: 0.5;
  filter: blur(8px);
  z-index: -1;
}
.brand h1 {
  margin: 0;
  font-size: 24px;
  font-weight: 700;
  letter-spacing: 0.3px;
  background: linear-gradient(135deg, #fff 30%, #b4c5ff);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
}
.tagline {
  color: var(--muted);
  margin: 6px 0 0;
  font-size: 13px;
  line-height: 1.5;
}

header .chip {
  flex: 0 0 auto;
  width: max-content;
  padding: 6px 10px;
}

.container {
  max-width: 1100px;
  margin: 12px auto 80px;
  padding: 24px;
  display: grid;
  grid-template-columns: 1.15fr 0.85fr;
  gap: 28px;
}

.card {
  background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.04));
  border: 1px solid var(--border);
  border-radius: 20px;
  box-shadow: var(--shadow);
  backdrop-filter: saturate(130%) blur(12px);
  padding: 24px;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
   overflow: hidden;
}
.card:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow), 0 0 0 1px var(--glass2);
}
.card h2 {
  margin: 0 0 12px;
  font-size: 18px;
  font-weight: 700;
  letter-spacing: 0.2px;
}
.grid2 {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 14px;
}
label {
  display: block;
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 6px;
}
input[type="text"], input[type="number"], select {
  width: 100%;
  padding: 14px 16px;
  border-radius: 14px;
  border: 1px solid var(--border);
  background: rgba(255,255,255,0.06);
  color: var(--text);
  outline: none;
  font-size: 14px;
  transition: all 0.2s ease;
}

/* MathQuill Styling */
.mq-editable-field {
  border: none !important;
  box-shadow: none !important;
  background: transparent !important;
  color: var(--text) !important;
  font-size: 16px !important;
}
/*Soham couldn't see the cursor so I updated the cursor color */
.mq-cursor {
  background-color: #ffffff !important; /* white cursor for MathQuill */
  border-left: 1px solid #ffffff !important; 
  height: 1em !important; 
}

/* New rule: Apply to all text inputs for consistency */
input[type="text"],
input[type="number"],
select,
.mq-editable-field {
  caret-color: #ffffff !important; /* White caret for regular inputs and MathQuill fallback */
}

.math-input-wrapper {
  position: relative;
  padding: 12px 16px;
  border-radius: 14px;
  border: 1px solid var(--border);
  background: rgba(255,255,255,0.06);
  margin-bottom: 8px;
  transition: all 0.2s ease;
}

.math-input-wrapper:hover {
  border-color: var(--glass2);
  background: rgba(255,255,255,0.08);
}

.math-input-wrapper:focus-within {
  border-color: var(--accent);
  background: rgba(255,255,255,0.08);
  box-shadow: 0 0 0 3px rgba(124, 92, 255, 0.15);
}
/* Improve mobile tap target */
.math-input-wrapper {
  min-height: 50px; /* Larger touch area */
  display: flex;
  align-items: center;
}

@media (max-width: 768px) {
  .math-input-wrapper {
    padding: 16px; /* More padding for fat-finger typing */
  }
}

.mq-math-mode {
  color: var(--text) !important;
}

.mq-math-mode .mq-sup {
  position: relative;
  top: -0.5em;
  font-size: 0.85em;
}

.mq-math-mode .mq-sub {
  position: relative;
  bottom: -0.4em;
  font-size: 0.85em;
}

.math-suggestions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 8px;
  padding: 0 4px;
}

.math-suggestion {
  background: var(--glass);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 4px 8px;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s ease;
  color: var(--text);
}

.math-suggestion:hover {
  background: var(--glass2);
  border-color: var(--accent);
}

.math-keyboard-toggle {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: var(--glass);
  border: 1px solid var(--border);
  border-radius: 8px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  color: var(--text);
}

.math-keyboard-toggle:hover {
  background: var(--glass2);
  border-color: var(--accent);
}

.math-keyboard {
  position: absolute;
  top: calc(100% + 8px);
  left: 0;
  right: 0;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 12px;
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 8px;
  z-index: 10;
  box-shadow: var(--shadow);
  display: none;
}

.math-keyboard.active {
  display: grid;
}

.math-key {
  background: var(--glass);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s ease;
  color: var(--text);
}

.math-key:hover {
  background: var(--glass2);
  border-color: var(--accent);
}
.chip {
  display: inline-flex;
  align-items: center;
  gap: 10px;
  padding: 14px 16px;
  border-radius: 14px;
  border: 1px solid var(--border);
  background: rgba(255,255,255,0.06);
  color: var(--text);
  outline: none;
  font-size: 14px;
  transition: all 0.2s ease;
  width: max-content;
}

.chip {
  width: auto;
  padding: 14px 16px;
  border-radius: 14px;
  border: 1px solid var(--border);
  background: rgba(255,255,255,0.06);
  color: var(--text);
  outline: none;
  font-size: 14px;
  transition: all 0.2s ease;
}

/* Enhanced select styles */
select {
  background-color: var(--bg2);
  font-weight: 500;
  position: relative;
  z-index: 1;
}
input::placeholder { 
  color: rgba(173, 180, 194, 0.4);
  transition: color 0.2s ease;
}
input:hover::placeholder {
  color: rgba(173, 180, 194, 0.5);
}
input:focus::placeholder {
  color: rgba(173, 180, 194, 0.6);
}
input:hover, select:hover {
  border-color: var(--glass2);
  background: rgba(255,255,255,0.08);
}
input:focus, select:focus {
  border-color: var(--accent);
  background: rgba(255,255,255,0.08);
  box-shadow: 0 0 0 3px rgba(124, 92, 255, 0.15);
}
select { 
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L6 6L11 1' stroke='%239ba3b0' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 16px center;
  padding-right: 40px;
  cursor: pointer;
}
select option {
  background-color: #162042;
  color: var(--text);
  padding: 12px;
  font-size: 14px;
}
/* Style for Firefox */
select:-moz-focusring {
  color: transparent;
  text-shadow: 0 0 0 var(--text);
}
/* Style for Webkit browsers */
select::-ms-expand {
  display: none;
}
select:focus option:checked {
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  color: #504e4e9e;
}
.row { display: flex; gap: 14px; }
.chip {
  display: inline-flex;
  align-items: center;
  gap: 10px;
  background: linear-gradient(180deg, var(--glass), rgba(255,255,255,0.05));
  padding: 8px 12px;
  border-radius: 12px;
  border: 1px dashed rgba(255,255,255,0.25);
  font-size: 13px;
  transition: all 0.2s ease;
  white-space: nowrap;
  width: fit-content;
}
.chip:hover {
  border-color: rgba(255,255,255,0.35);
  background: linear-gradient(180deg, var(--glass2), rgba(255,255,255,0.06));
}
.chip small { 
  color: var(--muted);
  font-weight: 500;
}
header .chip {
  flex-shrink: 0;
  margin-left: auto;
  transform-origin: right center;
  padding: 6px 10px;
  font-size: 12px;
  min-width: 0;
  width: auto;
}

.actions { 
  display: flex; 
  align-items: center;
  margin: 20px 0;
  flex-direction: row;
  justify-content: space-between;
  width: 100%;
  gap: clamp(8px, 2vw, 14px);
  flex-wrap: wrap;
}
.actions .chip {
  flex: 0 0 auto;
  width: max-content;
  min-width: min-content;
}
.btn {
  flex: 1 1 0;
  min-width: min(140px, 45%);
  cursor: pointer;
  border: none;
  font-weight: 600;
  letter-spacing: 0.3px;
  padding: clamp(10px, 2.5vw, 14px) clamp(16px, 3vw, 24px);
  transition: all 0.2s ease;
  position: relative;
  border-radius: clamp(10px, 2vw, 14px);
  font-size: clamp(13px, 2vw, 14px);
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}
.btn-primary {
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  color: #10121a;
  box-shadow: 0 10px 24px rgba(0,212,255,0.25);
}
.btn-primary:hover {
  transform: translateY(-1px);
  box-shadow: 0 12px 28px rgba(0,212,255,0.35);
}
.btn-ghost {
  background: var(--glass);
  color: var(--text);
}
.btn-ghost:hover {
  background: var(--glass2);
}
.btn:active { 
  transform: translateY(1px);
  box-shadow: 0 8px 20px rgba(0,212,255,0.2);
}

.result {
  margin-top: 16px;
  padding: 16px 20px;
  border-radius: 16px;
  background: linear-gradient(180deg, var(--glass), rgba(255,255,255,0.04));
  border: 1px solid var(--border);
  min-height: 56px;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden; /* Clip any overflow from .out */
  max-width: 100%; /* Prevent card expansion */
  box-sizing: border-box;
}
.result:hover {
  transform: translateY(-1px);
  border-color: var(--glass2);
  box-shadow: var(--shadow-sm);
}
.result .title {
  font-size: 13px;
  color: var(--muted);
  margin-bottom: 10px;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 8px;
}
.result .title::before {
  content: "•";
  color: var(--accent);
  font-size: 18px;
  line-height: 1;
}
.result .out {
  font-size: 16px;
  font-weight: 600;
  line-height: 1.5;
  overflow-x: auto;
  padding-bottom: 4px;
  max-width: 100%; /* Constrain to parent width */
  white-space: nowrap; /* Prevent wrapping; force horizontal scroll for long math */
  display: block; /* Ensure it's a scrollable block */
}
.result .out::-webkit-scrollbar {
  height: 4px;
}
.result .out::-webkit-scrollbar-track {
  background: rgba(255,255,255,0.05);
  border-radius: 2px;
}
.result .out::-webkit-scrollbar-thumb {
  background: var(--glass2);
  border-radius: 2px;
}
.error {
  color: var(--danger);
  font-size: 13px;
  margin-top: 10px;
  padding: 8px 12px;
  background: rgba(255, 92, 124, 0.1);
  border-radius: 8px;
  display: flex;
  align-items: center;
  gap: 8px;
}
.error::before {
  content: "!";
  font-weight: bold;
  color: currentColor;
}
.ok { 
  color: var(--success);
  position: relative;
}
.ok::after {
  content: "";
  display: inline-block;
  width: 6px;
  height: 6px;
  background: currentColor;
  border-radius: 50%;
  margin-left: 6px;
  animation: pulse 2s infinite;
}
@keyframes pulse {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.5); opacity: 0.5; }
  100% { transform: scale(1); opacity: 1; }
}

.panel {
  display: grid;
  gap: 16px;
}
.plot {
  width: 100%;
  height: 360px;
  border-radius: 16px;
  overflow: hidden;
  border: 1px solid var(--border);
  background: linear-gradient(180deg, var(--glass), rgba(255,255,255,0.03));
  transition: all 0.3s ease;
  box-shadow: inset 0 0 0 1px var(--glass);
}
.plot:hover {
  border-color: var(--glass2);
  box-shadow: var(--shadow-sm), inset 0 0 0 1px var(--glass2);
}

.footer {
  max-width: 1100px;
  margin: 12px auto;
  padding: 0 24px;
  color: var(--muted);
  font-size: 12px;
  display: flex; justify-content: space-between; align-items: center;
}

    @media (min-width: 981px) {
      header .chip {
        transform: scale(0.9);
      }
    }

    @media (min-width: 1200px) {
      header .chip {
        transform: scale(0.85);
      }
    }

    @media (max-width: 980px) {
      .container { 
        grid-template-columns: 1fr;
        padding: 16px;
      }
      header { 
        flex-direction: column; 
        align-items: flex-start; 
        gap: 16px;
        margin: 24px auto 16px;
        padding: 0 16px;
      }
      header .chip {
        margin-left: 0;
        align-self: flex-start;
      }
      .card {
        padding: 20px;
      }
      .grid2 {
        grid-template-columns: 1fr;
      }
      .plot {
        height: 280px;
      }
    }

    @media (max-width: 480px) {
      .actions {
        gap: 10px;
      }
      .actions .btn {
        flex: 1 1 100%;
        width: 100%;
        min-width: 100%;
      }
      .actions .chip {
        order: -1;
        width: 100%;
        justify-content: center;
      }
    }

    @media (min-width: 481px) and (max-width: 768px) {
      .actions .btn {
        min-width: calc(50% - 7px);
      }
    }

    /* Smooth scrolling and touch handling */
    @media (hover: hover) and (pointer: fine) {
      html {
        scroll-behavior: smooth;
      }
    }

    /* High contrast mode */
    @media (prefers-contrast: more) {
      :root {
        --border: rgba(255,255,255,0.25);
        --glass: rgba(255,255,255,0.12);
        --glass2: rgba(255,255,255,0.16);
      }
      .mq-cursor {
  background-color: #f3f6f3 !important; /* Bright green cursor */
}
    }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation: none !important;
        transition: none !important;
      }
    }
    .mq-editable-field.mq-empty::after {
      content: 'e.g. x^2 + sin(x)';
      color: var(--muted) !important;
      font-style: italic;
      pointer-events: none;
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0.6;
    }
    .mq-editable-field:not(.mq-empty)::after {
      content: none; /* Hide when not empty */
    }
  </style>
</head>
<body>
  <div class="aurora">
    <div class="blob"></div>
    <div class="blob2"></div>
  </div>

<header>
  <div class="brand">
    <div class="logo" aria-hidden="true"></div>
    <div>
      <h1>Calculex</h1>
      <p class="tagline">Differentiate, integrate, evaluate limits, and visualize functions.</p>
    </div>
  </div>
  <div class="chip">
    <small>Status</small>
    <span class="ok">Ready</span>
  </div>
</header>

<main class="container">
  <section class="card panel">
    <h2>Problem Setup</h2>
    <div>
      <label for="expr">Function f(x)</label>
      <div class="math-input-wrapper">
        <span id="math-input"></span>
        <button class="math-keyboard-toggle" id="keyboardToggle">⌨</button>
        <input type="hidden" id="expr" />
        <div class="math-keyboard" id="mathKeyboard">
          <!-- Will be populated by JavaScript -->
        </div>
      </div>
      <div class="math-suggestions" id="mathSuggestions">
        <!-- Will be populated by JavaScript -->
      </div>
    </div>
    <div class="grid2">
      <div>
        <label for="variable">Variable</label>
        <input id="variable" type="text" value="x" />
      </div>
      <div>
        <label for="op">Operation</label>
        <select id="op">
          <option value="evaluate">Evaluate f(x0)</option>
          <option value="differentiateSymbolic">Derivative (symbolic)</option>
          <option value="differentiateNumeric">Derivative at x0 (numeric)</option>
          <option value="integrateDefinite">Definite integral ∫ f dx from a to b</option>
          <option value="limit">Limit of f(x) at x0</option>
        </select>
      </div>
    </div>

<div class="grid2">
  <div>
    <label for="x0">x0 (for evaluate/limit/derivative at point)</label>
    <input id="x0" type="text" placeholder="e.g. 0, pi/3, sqrt(2)" />
  </div>
  <div>
    <label for="interval">Interval [a, b] (for integral / plot)</label>
    <input id="interval" type="text" placeholder="e.g. -2, 2" />
  </div>
</div>

<div class="actions">
  <button class="btn btn-primary" id="computeBtn">Compute</button>
  <button class="btn btn-ghost" id="plotBtn">Plot f(x)</button>
  <div class="chip"><small>Tolerance</small><span id="tolChip">1e-10</span></div>
</div>

  <div class="result">
    <div class="title">Result</div>
    <div class="out" id="resultLatex"></div>
    <div class="error" id="errorMsg"></div>
  </div>
</section>

  <section class="card">
    <h2>Visualization</h2>
    <div id="plot" class="plot"></div>
    <div class="grid2" style="margin-top:12px;">
      <div>
        <label for="samples">Plot samples</label>
        <input id="samples" type="number" min="50" max="2000" value="400" />
      </div>
      <div>
        <label for="domain">Plot domain [xmin, xmax]</label>
        <input id="domain" type="text" placeholder="e.g. -5, 5" />
      </div>
    </div>
  </section>
</main>

<div class="footer">
  <div>Supports standard math functions: sin, cos, tan, exp, log, sqrt, abs, floor, ceil, etc.</div>
  <div>Symbolic by math.js; numeric by adaptive Simpson and robust finite differences.</div>
</div>

<script>
  // Initialize MathQuill
  var MQ = MathQuill.getInterface(2);
  var mathField;

  // Common mathematical expressions and functions
  const suggestions = [
    { latex: 'x^2', title: 'Square' },
    { latex: '\\sqrt{x}', title: 'Square root' },
    { latex: 'e^x', title: 'Exponential' },
    { latex: '\\sin(x)', title: 'Sine' },
    { latex: '\\cos(x)', title: 'Cosine' }
  ];

  // Advanced mathematical functions for keyboard
  const mathKeys = [
    { latex: '+', type: 'operator' },
    { latex: '-', type: 'operator' },
    { latex: '\\cdot', type: 'operator', display: '×' },
    { latex: '\\div', type: 'operator', display: '÷' },
    { latex: '(', type: 'bracket' },
    { latex: ')', type: 'bracket' },
    { latex: '{', type: 'bracket' },
    { latex: '}', type: 'bracket' },
    { latex: '[', type: 'bracket' },
    { latex: ']', type: 'bracket' },
    { latex: '^', type: 'operator', display: 'x^n' },
    { latex: '_', type: 'operator', display: 'x_n' },
    { latex: '\\sqrt', type: 'function', display: '√' },
    { latex: '\\frac', type: 'template', display: 'a/b' },
    { latex: '\\sin', type: 'function' },
    { latex: '\\cos', type: 'function' },
    { latex: '\\tan', type: 'function' },
    { latex: '\\ln', type: 'function' },
    { latex: 'e^', type: 'template' },
    { latex: '\\pi', type: 'constant', display: 'π' }
  ];

 document.addEventListener('DOMContentLoaded', function() {
  // Initialize MathQuill field
  const mathInput = document.getElementById('math-input');
  mathField = MQ.MathField(mathInput, {
    spaceBehavesLikeTab: true,
    handlers: {
      edit: function() {
        const latex = mathField.latex();
        document.getElementById('expr').value = latexToMathJS(latex);
      }
    }
  });

  // Mobile detection and enhancements (added code starts here)
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

  // Force focus on touch for mobile (reuse existing mathInput var)
  mathInput.addEventListener('touchstart', function(e) {
    if (isMobile) {
      e.preventDefault(); // Prevent default zoom/scroll
      setTimeout(() => {
        mathField.focus(); // Delay to ensure keyboard opens
        // REMOVED: document.getElementById('expr').focus(); // Hidden inputs can't receive input!
      }, 100);
    }
  }, { passive: false });

  // NEW: Safer mobile re-focus on keypress (helps with Android/iOS input bugs; no internal override)
  if (isMobile) {
    mathInput.addEventListener('keyup', function(e) {
      // Re-focus after each key to keep cursor/keyboard active
      setTimeout(() => {
        mathField.focus();
      }, 50);
    });
    console.log('Mobile mode enabled: Keyup listener attached for re-focus.'); // TEMP DEBUG: Check console
  }

  // Add a mobile hint near the input (optional, for UX)
  const mobileHint = document.createElement('small');
  mobileHint.style.cssText = 'display: block; font-size: 11px; color: var(--muted); margin-top: 4px;';
  mobileHint.style.display = isMobile ? 'block' : 'none';
  document.querySelector('.math-input-wrapper').appendChild(mobileHint);
  // Mobile enhancements end here

  // Set initial expression EARLIER (before suggestions/keyboard, to ensure rendering)
  mathField.latex('x^2');
  console.log('Initial latex set to x^2'); // TEMP DEBUG: Check console

  // Initialize suggestions
  const suggestionContainer = document.getElementById('mathSuggestions');
  if (suggestionContainer) { // Safety check
    console.log('Suggestions container found'); // TEMP DEBUG
    suggestions.forEach(suggestion => {
      const btn = document.createElement('button');
      btn.className = 'math-suggestion';
      btn.innerHTML = `$${suggestion.latex}$`;
      btn.title = suggestion.title;
      btn.onclick = () => {
        mathField.write(suggestion.latex);
        mathField.focus();
      };
      suggestionContainer.appendChild(btn);
      // Render the math in the button
      katex.render(suggestion.latex, btn, { throwOnError: false });
    });
    console.log('Suggestions initialized'); // TEMP DEBUG
  } else {
    console.error('Suggestions container not found!'); // TEMP DEBUG
  }

  // Initialize keyboard
  const keyboard = document.getElementById('mathKeyboard');
  if (keyboard) { // Safety check
    console.log('Math keyboard container found'); // TEMP DEBUG
    mathKeys.forEach(key => {
      const btn = document.createElement('button');
      btn.className = 'math-key';
      btn.innerHTML = key.display || `$${key.latex}$`;
      btn.onclick = () => {
        mathField.write(key.latex);
        mathField.focus();
      };
      keyboard.appendChild(btn);
      if (!key.display) {
        katex.render(key.latex, btn, { throwOnError: false });
      }
    });
    console.log('Math keyboard initialized'); // TEMP DEBUG
  } else {
    console.error('Math keyboard container not found!'); // TEMP DEBUG
  }

  // Toggle keyboard
  const keyboardToggle = document.getElementById('keyboardToggle');
  if (keyboardToggle) {
    keyboardToggle.onclick = () => {
      keyboard.classList.toggle('active');
    };
    console.log('Keyboard toggle attached'); // TEMP DEBUG
  } else {
    console.error('Keyboard toggle not found!'); // TEMP DEBUG
  }

  // Close keyboard when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.math-input-wrapper')) {
      keyboard.classList.remove('active');
    }
  });

  console.log('DOMContentLoaded fully executed'); // TEMP DEBUG: Overall success
});
  // Convert LaTeX to math.js expression
  function latexToMathJS(latex) {
    return latex
      .replace(/\\cdot/g, '*')
      .replace(/\\div/g, '/')
      .replace(/\\frac{([^}]*)}{([^}]*)}/g, '($1)/($2)')
      .replace(/\\sqrt{([^}]*)}/g, 'sqrt($1)')
      .replace(/([0-9a-zA-Z_.]+)\^{([^}]*)}/g, '$1^($2)')
      .replace(/([0-9a-zA-Z_.]+)\^(\S)/g, '$1^$2')
      .replace(/\\sin/g, 'sin')
      .replace(/\\cos/g, 'cos')
      .replace(/\\tan/g, 'tan')
      .replace(/\\ln/g, 'log')
      .replace(/\\pi/g, 'pi')
      .replace(/\\left|\\right/g, '')
      .replace(/\{|\}/g, '')
      .trim();
  }

  // Utility: parse a value with math.js (supports constants like pi, sqrt(2), etc.)
  function parseValue(str) {
    if (!str || !String(str).trim()) throw new Error("Value is empty.");
    const node = math.parse(str);
    const code = node.compile();
    const val = code.evaluate();
    const num = Number(val);
    if (!isFinite(num)) throw new Error("Value evaluated to non-finite.");
    return num;
  }

// Make f(x): returns a JS function for numeric evaluation
function compileFunction(expr, variable='x') {
  const node = math.parse(expr);
  const code = node.compile();
  return (x) => {
    const scope = {};
    scope[variable] = x;
    const v = code.evaluate(scope);
    const num = Number(v);
    if (!isFinite(num)) throw new Error("f(x) returned non-finite number at x=" + x);
    return num;
  };
}

// Adaptive Simpson integration (provided; refined with domain guards)
function integrateAdaptiveSimpson(f, a, b, opts = {}) {
  const absTol = opts.absTol ?? 1e-10;
  const relTol = opts.relTol ?? 1e-10;
  const maxDepth = opts.maxDepth ?? 20;

function simpson(fa, fm, fb, a, b) {
  return (b - a) * (fa + 4 * fm + fb) / 6;
}

if (!isFinite(a) || !isFinite(b)) throw new Error("Integration limits must be finite.");
if (a === b) return 0;

const fa = f(a);
const fb = f(b);
const m = 0.5 * (a + b);
const fm = f(m);
const Sab = simpson(fa, fm, fb, a, b);

function recurse(a, fa, m, fm, b, fb, Sab, depth) {
  const lm = 0.5 * (a + m);
  const rm = 0.5 * (m + b);
  const flm = f(lm);
  const frm = f(rm);

const Sa = simpson(fa, flm, fm, a, m);
const Sb = simpson(fm, frm, fb, m, b);
const S12 = Sa + Sb;

const err = Math.abs(S12 - Sab);
const tol = 15 * Math.max(absTol, relTol * Math.abs(S12));

  if (err <= tol || depth >= maxDepth) {
    // Richardson correction
    return S12 + (S12 - Sab) / 15;
  }
  return recurse(a, fa, lm, flm, m, fm, Sa, depth + 1)
       + recurse(m, fm, rm, frm, b, fb, Sb, depth + 1);
}

  return recurse(a, fa, m, fm, b, fb, Sab, 0);
}

// Numeric derivative at x0 with adaptive step control
function derivativeNumeric(f, x0) {
  if (!isFinite(x0)) throw new Error("x0 must be finite.");
  // Base step size scaled by magnitude of x0
  let h = Math.max(1e-5, Math.abs(x0) * 1e-5);
  // Central difference with Richardson extrapolation
  function df(h) {
    const f1 = f(x0 + h);
    const f2 = f(x0 - h);
    return (f1 - f2) / (2 * h);
  }
  const d1 = df(h);
  const d2 = df(h / 2);
  // Extrapolate: O(h^2) error -> combine
  const rich = (4 * d2 - d1) / 3;
  return rich;
}

// Numeric limit of f(x) at x0 using symmetric sampling and robustness
function limitNumeric(f, x0) {
  if (!isFinite(x0)) throw new Error("x0 must be finite.");
  let h = Math.max(1e-5, Math.abs(x0) * 1e-5);
  const samples = [];
  for (let k = 0; k < 5; k++) {
    const hp = h / Math.pow(2, k);
    const left = f(x0 - hp);
    const right = f(x0 + hp);
    if (!isFinite(left) || !isFinite(right)) continue;
    samples.push(0.5 * (left + right));
  }
  if (!samples.length) throw new Error("Could not sample finite values near x0.");
  // Robust aggregate (trimmed mean)
  samples.sort((a,b)=>a-b);
  const trimmed = samples.slice(1, samples.length - 1);
  const arr = trimmed.length ? trimmed : samples;
  const avg = arr.reduce((s,v)=>s+v,0) / arr.length;
  return avg;
}

// Render LaTeX using KaTeX
function renderLatex(el, latex) {
  katex.render(latex, el, { 
    throwOnError: false, 
    displayMode: true,
    trust: true,
    macros: {
      "\\derivative": "\\frac{d}{d#1}",  // Custom macro for derivative
    },
    strict: false,
    linebreaks: false,  // Disable automatic line breaks
    maxSize: '100%',    // Limit render size to container
    wrap: false         // Prevent wrapping
  });
}

// Format number
function fmtNumber(x) {
  if (!isFinite(x)) return String(x);
  const abs = Math.abs(x);
  if (abs !== 0 && (abs < 1e-4 || abs >= 1e6)) {
    return x.toExponential(8);
  }
  return Number(x.toFixed(10)).toString();
}

// Compute handler
const resultEl = document.getElementById('resultLatex');
const errorEl = document.getElementById('errorMsg');

document.getElementById('computeBtn').addEventListener('click', () => {
  errorEl.textContent = '';
  resultEl.textContent = '';
  try {
    const expr = document.getElementById('expr').value.trim();
    const variable = document.getElementById('variable').value.trim() || 'x';
    const op = document.getElementById('op').value;
    const x0Str = document.getElementById('x0').value.trim();
    const intervalStr = document.getElementById('interval').value.trim();

if (!expr) throw new Error("Enter a function expression.");
const f = compileFunction(expr, variable);

    if (op === 'evaluate') {
      if (!x0Str) throw new Error("Enter x0 for evaluation.");
      const x0 = parseValue(x0Str);
      const y = f(x0);

      try {
        // Get the function in proper LaTeX
        const node = math.parse(expr);
        const functionLatex = node.toTex({
          parenthesis: 'keep',
          implicit: 'hide'
        });

        // Parse x0 to get its LaTeX representation
        const x0Node = math.parse(x0Str);
        const x0Latex = x0Node.toTex({
          parenthesis: 'keep',
          implicit: 'hide'
        });

        // Format the complete result with proper alignment
        const resultLatex = `\\begin{aligned}
          f(${variable}) &= ${functionLatex} \\\\[6pt]
          ${variable}_0 &= ${x0Latex} \\\\[6pt]
          f(${x0Latex}) &= ${fmtNumber(y)}
        \\end{aligned}`;
        
        renderLatex(resultEl, resultLatex);
      } catch (err) {
        // Fallback to simple format if parsing fails
        renderLatex(resultEl, `f(${variable}) = ${expr},\\quad f(${x0Str}) = ${fmtNumber(y)}`);
      }
    } else if (op === 'differentiateSymbolic') {
      try {
        // Get the original function in LaTeX
        const originalNode = math.parse(expr);
        const originalLatex = originalNode.toTex({
          parenthesis: 'keep',
          implicit: 'hide'
        });

        // Get the derivative
        const dnode = math.derivative(expr, variable);
        
        // Convert derivative to LaTeX
        const derivativeLatex = dnode.toTex({
          parenthesis: 'keep',
          implicit: 'hide'
        });

        // Format the complete result with proper spacing and alignment
        const resultLatex = `f(${variable}) = ${originalLatex}\\\\[8pt]
        \\frac{d}{d${variable}}f(${variable}) = ${derivativeLatex}`;
        
        renderLatex(resultEl, resultLatex);
      } catch (err) {
        throw new Error("Could not compute symbolic derivative: " + err.message);
      }
    } else if (op === 'differentiateNumeric') {
      if (!x0Str) throw new Error("Enter x0 for derivative.");
      const x0 = parseValue(x0Str);
      const df = derivativeNumeric(f, x0);
      renderLatex(resultEl, `\\left.\\dfrac{df}{d${variable}}\\right|_{${variable}=${fmtNumber(x0)}} \\approx ${fmtNumber(df)}`);
    } else if (op === 'integrateDefinite') {
      if (!intervalStr) throw new Error("Enter interval as a, b.");
      const parts = intervalStr.split(',').map(s => s.trim());
      if (parts.length !== 2) throw new Error("Interval must be two comma-separated values.");
      const a = parseValue(parts[0]);
      const b = parseValue(parts[1]);
      const I = integrateAdaptiveSimpson(f, a, b, { absTol: 1e-10, relTol: 1e-10, maxDepth: 20 });
      renderLatex(resultEl, `\\int_{${fmtNumber(a)}}^{${fmtNumber(b)}} f(${variable})\\, d${variable} \\approx ${fmtNumber(I)}`);
    } else if (op === 'limit') {
      if (!x0Str) throw new Error("Enter x0 for limit.");
      const x0 = parseValue(x0Str);
      const L = limitNumeric(f, x0);
      renderLatex(resultEl, `\\lim_{${variable}\\to ${fmtNumber(x0)}} f(${variable}) \\approx ${fmtNumber(L)}`);
    } else {
      throw new Error("Unknown operation.");
    }
  } catch (err) {
    errorEl.textContent = err.message || String(err);
  }
});

// Plot handler
document.getElementById('plotBtn').addEventListener('click', () => {
  errorEl.textContent = '';
  try {
    const expr = document.getElementById('expr').value.trim();
    const variable = document.getElementById('variable').value.trim() || 'x';
    const domainStr = document.getElementById('domain').value.trim();
    const samples = Number(document.getElementById('samples').value) || 400;
    if (!expr) throw new Error("Enter a function expression.");
    const f = compileFunction(expr, variable);
    let xmin = -5, xmax = 5;
    if (domainStr) {
      const parts = domainStr.split(',').map(s => s.trim());
      if (parts.length !== 2) throw new Error("Domain must be two comma-separated values.");
      xmin = parseValue(parts[0]);
      xmax = parseValue(parts[1]);
    } else {
      // fallback from integral interval if provided
      const intervalStr = document.getElementById('interval').value.trim();
      if (intervalStr) {
        const parts = intervalStr.split(',').map(s => s.trim());
        if (parts.length === 2) {
          xmin = parseValue(parts[0]);
          xmax = parseValue(parts[1]);
        }
      }
    }
    if (!(isFinite(xmin) && isFinite(xmax)) || xmin === xmax) throw new Error("Invalid domain.");
    const x = [];
    const y = [];
    const N = Math.max(50, Math.min(2000, samples));
    for (let i = 0; i < N; i++) {
      const xi = xmin + (xmax - xmin) * (i / (N - 1));
      let yi;
      try { yi = f(xi); }
      catch { yi = NaN; }
      x.push(xi);
      y.push(isFinite(yi) ? yi : NaN);
    }
    Plotly.newPlot('plot', [{
      x, y, type: 'scatter', mode: 'lines',
      line: { color: '#00D4FF', width: 2 },
      hovertemplate: 'x=%{x:.6f}<br>f=%{y:.6f}<extra></extra>'
    }], {
      paper_bgcolor: 'rgba(0,0,0,0)',
      plot_bgcolor: 'rgba(0,0,0,0)',
      margin: { l: 40, r: 20, t: 10, b: 40 },
      xaxis: { gridcolor: 'rgba(255,255,255,0.08)', zerolinecolor: 'rgba(255,255,255,0.18)', color: '#cdd3e0' },
      yaxis: { gridcolor: 'rgba(255,255,255,0.08)', zerolinecolor: 'rgba(255,255,255,0.18)', color: '#cdd3e0' }
    }, { displayModeBar: true, responsive: true });

    // Create a nicer formatted result with proper math formatting
    let resultLatex = `f(${variable}) = `;
    
    // Convert the expression to proper LaTeX
    try {
      // Parse with math.js and convert to LaTeX
      const node = math.parse(expr);
      const latex = node.toTex({
        parenthesis: 'keep',
        implicit: 'hide'
      });
      resultLatex += latex;
    } catch {
      // Fallback if math.js can't parse it
      resultLatex += `\\text{${expr}}`;
    }

    // Add the domain information
    resultLatex += `,\\quad x \\in [${fmtNumber(xmin)}, ${fmtNumber(xmax)}]`;
    
    renderLatex(resultEl, resultLatex);
  } catch (err) {
    errorEl.textContent = err.message || String(err);
  }
});

    // Initialize
    renderLatex(resultEl, "Enter an expression and choose an operation.");
  </script>
</body>
</html>