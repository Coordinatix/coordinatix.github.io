<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=STIX+Two+Math&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css">
  <title>Coordinatix 3D</title>
  <style>
    /* CSS unchanged from your original */
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
    body, html { width: 100%; height: 100%; overflow: auto; }
    #canvas-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; background-color: #000; overflow: hidden; }
    #sidebar { position: fixed; top: 30px; left: 30px; width: 300px; height: calc(100vh - 60px); overflow-y: auto; padding: 20px; background: rgba(255, 255, 255, 0.2); border-radius: 16px; z-index: 10; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3); backdrop-filter: blur(10px); color: #fff; }
    #sidebar h2 { font-size: 1.5em; margin-bottom: 20px; }
    .equation-input { width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid rgba(255,255,255,0.4); border-radius: 6px; background: rgba(255, 255, 255, 0.3); color: #fff; }
    .equation-row { display: flex; align-items: center; margin-bottom: 10px; }
    .equation-input { 
      flex: 1; 
      padding: 0; 
      border: 1px solid rgba(255,255,255,0.4) !important; 
      border-radius: 6px 0 0 6px; 
      background: rgba(255, 255, 255, 0.05); 
      color: #ffffff; 
      margin: 0;
      font-size: 14px;
      font-family: 'STIX Two Math', serif;
      position: relative;
      min-height: 42px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      overflow: visible;
      z-index: 0;
    }
    button { padding: 10px 14px; margin: 5px 0; border: none; border-radius: 6px; cursor: pointer; background: #00aaff; color: white; transition: background 0.2s ease; }
    button:hover { background: #0077cc00; }
    .remove-btn { padding: 10px 14px; background: rgba(255, 80, 80, 0); color: white; border: none; cursor: pointer; border-radius: 0 6px 6px 0; height: 100%; font-size: 1.2em; }
    .remove-btn:hover { transform: scale(1.2); }
    #error { color: #ff8888; font-size: 0.9em; margin-top: 10px; }
    @media (max-width: 768px) { #sidebar { width: 90%; left: 5%; } }

    .equation-input.empty::before {
      content: attr(data-placeholder);
      color: rgba(255, 255, 255, 0.5);
      position: absolute;
      top: 50%;
      left: 10px;
      transform: translateY(-50%);
      pointer-events: none;
      font-family: 'STIX Two Math', serif;
      font-size: 14px;
      z-index: 0;
    }

    .equation-input .mq-editable-field {
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
      width: 100% !important;
      padding: 0 !important;
      position: relative !important;
      left: auto !important;
      top: auto !important;
      transform: none !important;
      min-height: 38px !important;
      display: flex !important;
      align-items: center !important;
    }

    .equation-input .mq-root-block {
      display: flex !important;
      align-items: center !important;
      width: 100% !important;
      min-height: 38px !important;
      padding: 0 !important;
      margin: 0 !important;
    }

    .equation-input .mq-math-mode {
      background: transparent !important;
    }

    .mq-root-block,
    .mq-editable-field,
    .mq-math-mode,
    .mq-root-block span,
    .mq-numeral {
      font-family: 'STIX Two Math', 'Times New Roman', serif !important;
      font-size: 14px !important;
      color: inherit;
    }

    .equation-input .mq-math-mode {
      border: none !important;
      box-shadow: none !important;
    }

    .mq-sup {
      vertical-align: super !important;
      font-size: 0.7em !important;
      position: relative !important;
      top: -0.3em !important;
    }

    .equation-prepared {
      padding: 10px !important;
    }

    .equation-input:focus-within {
      box-shadow: 0 0 8px 2.5px rgba(220, 231, 229, 0.4);
      border-radius: 6px;
    }
    .equation-input .mq-cursor {
      animation: blink 1s steps(1) infinite;
      border-left: 1px solid white !important;
    }
    .mq-cursor {
      border-left: 1px solid white !important;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>Coordinatix 3D</h2>
    <div id="equations"></div>
    <div id="error"></div>
  |</div>
  <div id="canvas-container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.0/math.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js"></script>
  <script>
    var MQ = MathQuill.getInterface(2);
  </script>

  <script>
    let scene, camera, renderer, controls, typingTimer;
    const equations = [];
    const meshes = [];
    const range = 10;
    const resolution = 100;

    function preprocess(expr) {
      if (!expr) return '0.0';
      
      // Clean LaTeX commands and special characters
      let cleaned = expr
        .replace(/\\left/g, '')
        .replace(/\\right/g, '')
        .replace(/\\sin/g, 'sin')
        .replace(/\\cos/g, 'cos')
        .replace(/\\tan/g, 'tan')
        .replace(/\\pi/g, 'pi')
        .replace(/\\e/g, 'e')
        .replace(/\\frac{([^}]*)}{([^}]*)}/g, '($1)/($2)') // Convert fractions
        .replace(/\s+/g, ''); // Remove all whitespace

      // Handle implicit multiplication
      cleaned = cleaned
        .replace(/(\d)([a-zA-Z])/g, '$1*$2') // 2x -> 2*x
        .replace(/([a-zA-Z])(\d)/g, '$1*$2') // x2 -> x*2
        .replace(/\)([a-zA-Z\d(])/g, ')*$1') // )x -> )*x, )(  -> )*(
        .replace(/([a-zA-Z\d])\(/g, '$1*('); // x( -> x*(

      return cleaned;
    }

    function isBalanced(str) {
      let stack = [];
      for (let ch of str) {
        if ("([{".includes(ch)) stack.push(ch);
        if (")]}".includes(ch)) {
          const last = stack.pop();
          if (!last || "([{".indexOf(last) !== ")]}".indexOf(ch)) return false;
        }
      }
      return stack.length === 0;
    }
    

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(5, 5, 10);
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      scene.add(new THREE.AxesHelper(5));
      scene.add(new THREE.GridHelper(20, 20));

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    }

    function mathjsToGLSL(node) {
      switch (node.type) {
        case 'SymbolNode':
          if (['x', 'y'].includes(node.name)) return node.name;
          if (node.name === 'pi') return '3.14159265359';
          if (node.name === 'e') return '2.71828182846';
          throw new Error(`Unsupported variable: ${node.name}`);

        case 'ConstantNode':
          const val = Number(node.value);
          return Number.isInteger(val) ? `${val}.0` : `${val}`;

        case 'OperatorNode':
          const [a, b] = node.args.map(mathjsToGLSL);
          switch (node.op) {
            case '+': return `(${a} + ${b})`;
            case '-': return `(${a} - ${b})`;
            case '*': return `(${a} * ${b})`;
            case '/': return `(${a} / (${b} != 0.0 ? ${b} : 1e-10))`; // Avoid division by zero
            case '^': return `pow(${a}, ${b})`;
            default: throw new Error(`Unsupported operator: ${node.op}`);
          }

        case 'FunctionNode': {
          const fn = node.fn.name;
          const args = node.args.map(mathjsToGLSL).join(', ');
          const supported = {
            sin: 'sin', cos: 'cos', tan: 'tan',
            asin: 'asin', acos: 'acos', atan: 'atan',
            sinh: 'sinh', cosh: 'cosh', tanh: 'tanh',
            exp: 'exp', log: 'log', log10: 'log',
            sqrt: 'sqrt', abs: 'abs'
          };
          if (fn === 'log10') return `(log(${args})/log(10.0))`;
          if (supported[fn]) return `${supported[fn]}(${args})`;
          throw new Error(`Unsupported function: ${fn}`);
        }

        case 'ParenthesisNode': {
          return `(${mathjsToGLSL(node.content)})`;
        }

        default: {
          throw new Error(`Unsupported node type: ${node.type}`);
        }
      }
    }

    function safeToGLSL(exprString) {
      if (!exprString.trim()) return '0.0';
      try {
        const processedExpr = preprocess(exprString);
        console.log('Preprocessed:', processedExpr); // Debug
        const node = math.parse(processedExpr);
        const glsl = mathjsToGLSL(node);
        console.log('GLSL:', glsl); // Debug
        return glsl;
      } catch (err) {
        console.error('GLSL conversion error:', err);
        throw new Error(`Invalid equation: ${err.message}`);
      }
    }

    function createShaderMaterial(equationGLSL, color) {
      return new THREE.ShaderMaterial({
        vertexShader: `
          varying vec3 vColor;
          varying vec3 vPosition;
          varying vec3 vNormal;

          float f(float x, float y) {
            float z = ${equationGLSL};
            return isnan(z) || isinf(z) ? 0.0 : z;
          }

          void main() {
            float x = position.x;
            float y = position.y;
            float z = f(x, y);
            
            // Calculate surface normal for shading
            float eps = 0.01;
            float dx = (f(x + eps, y) - f(x - eps, y)) / (2.0 * eps);
            float dy = (f(x, y + eps) - f(x, y - eps)) / (2.0 * eps);
            vec3 normal = normalize(vec3(-dx, -dy, 1.0));
            
            vPosition = vec3(x, y, z);
            vNormal = normal;
            vColor = vec3(${color.r.toFixed(2)}, ${color.g.toFixed(2)}, ${color.b.toFixed(2)});

            gl_Position = projectionMatrix * modelViewMatrix * vec4(vPosition, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          varying vec3 vPosition;
          varying vec3 vNormal;

          void main() {
            vec3 cornerLight = normalize(vec3(0.8, 0.6, 0.4));
            float diffuse = max(dot(vNormal, cornerLight), 0.0);
            diffuse = smoothstep(0.0, 1.0, diffuse);
            vec3 shadedColor = vColor * (0.45 + 0.55 * diffuse);
            gl_FragColor = vec4(shadedColor, 1.0);
          }
        `,
        side: THREE.DoubleSide,
        wireframe: false
      });
    }

    function updateEquation(index, text) {
      if (!text.trim()) {
        document.getElementById('error').innerText = '';
        if (meshes[index]) {
          scene.remove(meshes[index]);
          meshes[index].geometry.dispose();
          meshes[index].material.dispose();
          meshes[index] = null;
        }
        return;
      }

      if (!equations[index]) {
        document.getElementById('error').innerText = '';
        return;
      }

      let equationGLSL;
      try {
        equationGLSL = safeToGLSL(text.trim());
        console.log('Updating equation', index, 'GLSL:', equationGLSL); // Debug
      } catch (err) {
        document.getElementById('error').innerText = `Invalid equation: ${err.message}`;
        return;
      }

      document.getElementById('error').innerText = '';

      if (meshes[index]) {
        scene.remove(meshes[index]);
        meshes[index].geometry.dispose();
        meshes[index].material.dispose();
        meshes[index] = null;
      }

      try {
        const geometry = new THREE.PlaneGeometry(range * 2, range * 2, resolution, resolution);
        const color = new THREE.Color(equations[index].color);
        const material = createShaderMaterial(equationGLSL, color);
        const mesh = new THREE.Mesh(geometry, material);
        meshes[index] = mesh;
        scene.add(mesh);
        console.log('Mesh added to scene:', index); // Debug
      } catch (e) {
        document.getElementById('error').innerText = `Error in equation ${index + 1}: ${e.message}`;
      }
    }

    function addEquation(equationText = '', placeholder = 'Enter equation, e.g., x+y') {
      const container = document.getElementById('equations');
      const index = equations.length;
      equations.push({ text: equationText, color: getRandomColor() });

      const row = document.createElement('div');
      row.className = 'equation-row';

      const mathSpan = document.createElement('span');
      mathSpan.className = 'equation-input';
      mathSpan.dataset.placeholder = placeholder;
      mathSpan.classList.toggle('empty', equationText.trim() === '');

      const mathField = MQ.MathField(mathSpan, {
        spaceBehavesLikeTab: true,
        handlers: {
          edit: () => {
            const rawValue = mathField.latex().replace(/\s+/g, '');
            mathSpan.classList.toggle('empty', rawValue === '');
            clearTimeout(typingTimer);
            typingTimer = setTimeout(() => {
              const trimmedValue = rawValue.trim();
              if (trimmedValue && isBalanced(trimmedValue)) {
                try {
                  equations[index].text = trimmedValue;
                  updateEquation(index, trimmedValue);
                } catch (err) {
                  console.error('Equation parsing error:', err);
                  document.getElementById('error').innerText = `Error: ${err.message}`;
                }
              } else if (!trimmedValue) {
                document.getElementById('error').innerText = '';
                updateEquation(index, '');
              } else {
                document.getElementById('error').innerText = 'Unbalanced parentheses';
              }
            }, typingDelay);
          }
        }
      });

      if (equationText) {
        const latexText = equationText
          .replace(/sin/g, '\\sin')
          .replace(/cos/g, '\\cos')
          .replace(/tan/g, '\\tan')
          .replace(/pi/g, '\\pi');
        setTimeout(() => mathField.latex(latexText), 0);
      }

      mathSpan.classList.toggle('empty', equationText.trim() === '');

      const removeBtn = document.createElement('button');
      removeBtn.className = 'remove-btn';
      removeBtn.innerHTML = '<i class="fas fa-trash"></i>';
      removeBtn.onclick = () => {
        equations[index] = null;
        if (meshes[index]) {
          scene.remove(meshes[index]);
          meshes[index].geometry.dispose();
          meshes[index].material.dispose();
          meshes[index] = null;
        }
        container.removeChild(row);
        const remainingRows = document.querySelectorAll('.equation-row').length;
        if (remainingRows < 1) {
          addEquation('', placeholder);
        }
      };

      row.appendChild(mathSpan);
      row.appendChild(removeBtn);
      container.appendChild(row);
    }

    function getRandomColor() {
      return `#${Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0')}`;
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    init();
    addEquation('x+y'); // Simplified initial equation
    addEquation('');
  </script>
</body>
</html>