<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Sound — Fixed (module resolution)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin: 0; background: #07070a; color: #eee; font-family: system-ui, -apple-system, 'Segoe UI', Roboto; }
    #ui { position: absolute; top: 12px; left: 12px; z-index: 20; }
    button { margin-right: 8px; padding:6px 10px; }
    #tooltip { position: absolute; padding: 6px 8px; background: rgba(0,0,0,0.7); border: 1px solid #333; border-radius: 4px; display: none; pointer-events: none; white-space: pre; font-size: 12px; }
    canvas { display: block; width:100vw; height:100vh; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <button id="freezeBtn">Freeze Layout</button>
    <button id="exportBtn">Export JSON</button>
    <span id="status" style="margin-left:8px;font-size:13px;opacity:0.8"></span>
  </div>
  <div id="tooltip"></div>
  <canvas id="scene"></canvas>

  <!--
    IMPORTANT: The previous version imported OrbitControls as an ES module which
    caused the browser to try to resolve the bare specifier "three" inside the
    controls file. Browsers can't resolve bare specifiers without import maps
    or a bundler. To avoid that, we load the UMD builds as globals:
      - three (UMD)
      - OrbitControls (non-module example that attaches to THREE)
      - umap-js and meyda as globals

    This keeps the page runnable without a bundler or server-side tooling.
  -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/umap-js@1.4.1/dist/umap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/meyda@5.5.0/dist/web/meyda.min.js"></script>

  <script>
    // Use globals: THREE, UMAP, Meyda

    // --- Audio Feature Engine (uses analyser + Meyda.extract) ---
    class AudioFeatureEngine {
      constructor() {
        this.audioCtx = null;
        this.stream = null;
        this.sourceNode = null;
        this.analyser = null;
        this.bufferSize = 2048;
        this.frameInterval = 128; // ms
        this._energyWindow = [];
        this._currentSyll = null;
        this._frameIndex = 0;
        this._pollTimer = null;
        this.onSyllable = null;
        this.signalBuf = new Float32Array(this.bufferSize);
      }

      async start(onSyllable) {
        this.onSyllable = onSyllable;
        if (this.audioCtx && this.audioCtx.state === 'suspended') await this.audioCtx.resume();
        if (!this.audioCtx) this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        this.stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true }, video: false });
        this.sourceNode = this.audioCtx.createMediaStreamSource(this.stream);
        this.analyser = this.audioCtx.createAnalyser();
        this.analyser.fftSize = this.bufferSize;
        this.sourceNode.connect(this.analyser);

        // allocate typed array for waveform
        this.timeDomain = new Float32Array(this.analyser.fftSize);

        // small warm-up window
        this._energyWindow = [];
        this._frameIndex = 0;

        // start periodic polling rather than deprecated ScriptProcessor
        this._pollTimer = setInterval(()=>this._pullFrame(), this.frameInterval);
      }

      stop() {
        if (this._pollTimer) { clearInterval(this._pollTimer); this._pollTimer = null; }
        if (this.stream) this.stream.getTracks().forEach(t => t.stop());
        if (this.sourceNode) { try { this.sourceNode.disconnect(); } catch(e){} }
        if (this.analyser) { try { this.analyser.disconnect(); } catch(e){} }
        // keep audioCtx around so spatial audio can reuse it; close only if explicitly wanted
        this.stream = null;
      }

      _pullFrame() {
        if (!this.analyser) return;
        this.analyser.getFloatTimeDomainData(this.timeDomain);
        // Meyda.extract expects an Array or Float32Array; pass Float32Array for efficiency
        const features = Meyda.extract(['mfcc','rms','zcr','spectralCentroid','spectralFlatness'], this.timeDomain, { sampleRate: this.audioCtx.sampleRate }) || {};
        this._processFrame(features);
      }

      _processFrame(f) {
        const time = this._frameIndex * (this.frameInterval/1000);
        this._frameIndex++;
        if (!f) return;
        const energy = (f.rms || 0);
        const zcr = (f.zcr || 0);

        // rolling energy baseline
        this._energyWindow.push(energy);
        if (this._energyWindow.length > 50) this._energyWindow.shift();
        const meanE = this._energyWindow.reduce((a,b)=>a+b,0) / Math.max(1,this._energyWindow.length);
        const stdE = Math.sqrt(this._energyWindow.reduce((a,b)=>a+(b-meanE)*(b-meanE),0) / Math.max(1,this._energyWindow.length));
        const thresh = meanE + 0.5 * stdE;

        const voiced = energy > Math.max(1e-6, thresh) && zcr < 0.5;
        if (voiced && !this._currentSyll) {
          this._currentSyll = { start: time, frames: [] };
        }
        if (this._currentSyll) {
          this._currentSyll.frames.push({ time, energy, zcr, mfcc: f.mfcc || new Array(13).fill(0), sc: f.spectralCentroid || 0, sf: f.spectralFlatness || 0 });
          const over = energy < meanE * 0.85;
          const long = (time - this._currentSyll.start) > 1.2;
          if (over || long) {
            const syll = this._finalizeSyllable(this._currentSyll);
            this._currentSyll = null;
            if (syll) this.onSyllable && this.onSyllable(syll);
          }
        }
      }

      _finalizeSyllable(s) {
        const frames = s.frames;
        if (!frames || frames.length < 3) return null;
        const mean = arr => arr.reduce((a,b)=>a+b,0)/arr.length;
        const energyArr = frames.map(f=>f.energy);
        const dur = frames[frames.length-1].time - frames[0].time;
        const mfcc = (function(){
          const K = frames[0].mfcc.length;
          const sum = new Array(K).fill(0);
          for (const fr of frames) for (let k=0;k<K;k++) sum[k]+=fr.mfcc[k]||0;
          return sum.map(x=>x/frames.length);
        })();
        const modAM = (Math.sqrt(energyArr.reduce((a,b)=>a+(b-mean(energyArr))*(b-mean(energyArr)),0)/energyArr.length) || 0) / Math.max(1e-6, mean(energyArr));
        const feature = [].concat(mfcc.slice(0,8), [ mean(frames.map(f=>f.sc)), mean(frames.map(f=>f.sf)), modAM, dur, mean(energyArr) ]);
        return {
          id: (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('syl-'+Date.now()+'-'+Math.random().toString(36).slice(2,9)),
          startTime: s.start,
          endTime: frames[frames.length-1].time,
          features: new Float32Array(feature),
          energyMean: mean(energyArr),
          frameCount: frames.length
        };
      }
    }

    // --- Reducer3D (batch UMAP; fits every N syllables to avoid thrashing) ---
    class Reducer3D {
      constructor({ nNeighbors = 8, minDist = 0.1, metric = 'cosine', batchSize = 6 } = {}) {
        this.nNeighbors = nNeighbors;
        this.minDist = minDist;
        this.metric = metric;
        this.data = [];
        this.embedded = [];
        this.batchSize = batchSize;
        this.umap = null;
      }
      add(vector) { this.data.push(Array.from(vector)); }
      fitTransformIfNeeded() {
        if (this.data.length < 2) return [];
        if (!this._lastFitCount) this._lastFitCount = 0;
        if (this.data.length - this._lastFitCount < this.batchSize && this.embedded.length>0) return this.embedded;
        try {
          this.umap = new UMAP({ nNeighbors: this.nNeighbors, minDist: this.minDist, nComponents: 3, metric: this.metric });
          const X = this._zscore(this.data);
          const e = this.umap.fit(X);
          const mins=[Infinity,Infinity,Infinity], maxs=[-Infinity,-Infinity,-Infinity];
          for (const p of e) for (let i=0;i<3;i++){ mins[i]=Math.min(mins[i],p[i]); maxs[i]=Math.max(maxs[i],p[i]); }
          const scales = maxs.map((mx,i)=> (mx-mins[i])||1);
          this.embedded = e.map(p=>p.map((v,i)=> ((v - mins[i]) / scales[i] - 0.5) * 2));
          this._lastFitCount = this.data.length;
          return this.embedded;
        } catch(err) {
          console.warn('UMAP fit failed',err);
          return this.embedded || [];
        }
      }
      knn(k=6) {
        const pts = this.embedded || [];
        const N = pts.length; if (N===0) return [];
        const neighbors = new Array(N).fill(0).map(()=>[]);
        for (let i=0;i<N;i++){
          const dists=[];
          for (let j=0;j<N;j++) if (i!==j){
            const dx=pts[i][0]-pts[j][0], dy=pts[i][1]-pts[j][1], dz=pts[i][2]-pts[j][2];
            dists.push({j, d: Math.hypot(dx,dy,dz)});
          }
          dists.sort((a,b)=>a.d-b.d);
          neighbors[i]=dists.slice(0,Math.min(k,dists.length)).map(o=>o.j);
        }
        return neighbors;
      }
      _zscore(X){
        const d = X[0].length;
        const means = new Array(d).fill(0), stds = new Array(d).fill(1);
        for (let j=0;j<d;j++){
          const col = X.map(r=>r[j]);
          const m = col.reduce((a,b)=>a+b,0)/col.length;
          const s = Math.sqrt(col.reduce((a,b)=>a+(b-m)*(b-m),0)/col.length) || 1;
          means[j]=m; stds[j]=s;
        }
        return X.map(row=> row.map((v,j)=> (v - means[j]) / stds[j]));
      }
    }

    // --- Visualization ---
    class NervousSystem3D {
      constructor(canvas) {
        this.canvas = canvas;
        this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        this.renderer.setPixelRatio(window.devicePixelRatio || 1);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x07070a);
        this.camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.01, 200);
        this.camera.position.set(0, 0, 6);
        // Use the non-module OrbitControls which attaches to THREE
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;

        const light = new THREE.PointLight(0xffffff, 1.2);
        light.position.set(2,2,4);
        this.scene.add(light);

        this.nodesGroup = new THREE.Group();
        this.edgesGroup = new THREE.Group();
        this.scene.add(this.nodesGroup);
        this.scene.add(this.edgesGroup);

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.tooltip = document.getElementById('tooltip');

        window.addEventListener('resize', ()=>this._onResize());
        this.renderer.domElement.addEventListener('mousemove', (e)=>this._onMouseMove(e));
        this.renderer.domElement.addEventListener('click', (e)=>this._onClick(e));

        this._anim = this._animate.bind(this);
        requestAnimationFrame(this._anim);
      }

      setData(nodes, neighbors) {
        this.nodesGroup.clear(); this.edgesGroup.clear();
        const sphereGeo = new THREE.SphereGeometry(0.03, 10, 10);
        for (const n of nodes) {
          const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(...n.color), emissive: new THREE.Color(...n.color).multiplyScalar(0.2) });
          const mesh = new THREE.Mesh(sphereGeo, mat);
          mesh.position.set(...n.position);
          mesh.scale.setScalar(n.size || 0.02);
          mesh.userData = n;
          this.nodesGroup.add(mesh);
        }
        const lineMat = new THREE.LineBasicMaterial({ color: 0x88aaff, transparent: true, opacity: 0.28 });
        for (let i=0;i<nodes.length;i++){
          for (const j of (neighbors[i]||[])){
            const geom = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(...nodes[i].position), new THREE.Vector3(...nodes[j].position)
            ]);
            const line = new THREE.Line(geom, lineMat);
            this.edgesGroup.add(line);
          }
        }
      }

      _onResize(){
        this.camera.aspect = window.innerWidth/window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
      }

      _animate(){
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
        requestAnimationFrame(this._anim);
      }

      _onMouseMove(e){
        const rect = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.nodesGroup.children);
        if (intersects.length > 0) {
          const obj = intersects[0].object; const d = obj.userData;
          this.tooltip.style.display = 'block';
          this.tooltip.style.left = `${e.clientX + 10}px`;
          this.tooltip.style.top = `${e.clientY + 10}px`;
          this.tooltip.innerText =
            `Syllable ${d.id.slice(0,8)}\n`+
            `t: ${d.startTime.toFixed(2)}–${d.endTime.toFixed(2)} s\n`+
            `energy: ${d.energyMean.toFixed(4)}\n`+
            `frames: ${d.frameCount}`;
        } else this.tooltip.style.display = 'none';
      }

      _onClick(e){
        const rect = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.nodesGroup.children);
        if (intersects.length>0){
          const obj = intersects[0].object; const d = obj.userData;
          obj.material.emissiveIntensity = 0.8;
          setTimeout(()=>obj.material.emissiveIntensity = 0.2, 200);
          SpatialAudioEngine.playPingAt(d.position);
        }
      }
    }

    // --- Spatial audio ---
    class SpatialAudioEngine {
      static init(audioCtx){ SpatialAudioEngine.ctx = audioCtx; }
      static playPingAt(pos){
        const ctx = SpatialAudioEngine.ctx; if (!ctx) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        // Use WebAudio PannerNode constructor
        const panner = (typeof PannerNode !== 'undefined') ? new PannerNode(ctx, { panningModel: 'HRTF', distanceModel: 'inverse' }) : ctx.createPanner();
        if (panner.positionX) { panner.positionX.value = pos[0]*3; panner.positionY.value = pos[1]*3; panner.positionZ.value = pos[2]*3; }
        else panner.setPosition && panner.setPosition(pos[0]*3, pos[1]*3, pos[2]*3);
        osc.type = 'sine'; osc.frequency.value = 880 - (pos[1]*200);
        gain.gain.setValueAtTime(0.0001, ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.2, ctx.currentTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.35);
        osc.connect(gain).connect(panner).connect(ctx.destination);
        osc.start(); osc.stop(ctx.currentTime + 0.35);
      }
    }

    // --- App orchestration ---
    class App {
      constructor(){
        this.canvas = document.getElementById('scene');
        this.vis = new NervousSystem3D(this.canvas);
        this.engine = new AudioFeatureEngine();
        this.reducer = new Reducer3D({ nNeighbors: 8, minDist: 0.1, metric: 'cosine', batchSize: 4 });
        this.syllables = [];
        this.nodes = [];
        this.neighbors = [];
        this.frozen = false;

        document.getElementById('startBtn').onclick = ()=>this.start();
        document.getElementById('stopBtn').onclick = ()=>this.stop();
        document.getElementById('freezeBtn').onclick = ()=>{ this.frozen = !this.frozen; document.getElementById('freezeBtn').innerText = this.frozen ? 'Unfreeze Layout' : 'Freeze Layout'; };
        document.getElementById('exportBtn').onclick = ()=>this.exportJSON();
      }

      async start(){
        document.getElementById('status').innerText = 'listening...';
        await this.engine.start((syll)=>this._onSyllable(syll));
        SpatialAudioEngine.init(this.engine.audioCtx);
      }

      stop(){
        document.getElementById('status').innerText = '';
        this.engine.stop();
      }

      exportJSON(){
        const payload = { syllables: this.syllables.map(s=>({id:s.id,start:s.startTime,end:s.endTime,energy:s.energyMean,frames:s.frameCount})) };
        const blob = new Blob([JSON.stringify(payload,null,2)], { type: 'application/json' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'session.json'; a.click();
      }

      _onSyllable(s){
        this.syllables.push(s);
        this.reducer.add(s.features);
        const embedded = this.reducer.fitTransformIfNeeded();
        if (!embedded || embedded.length===0) return;
        const eMin = Math.min(...this.syllables.map(x=>x.energyMean));
        const eMax = Math.max(...this.syllables.map(x=>x.energyMean));
        const val = (x)=> (eMax===eMin)?0.5:((x.energyMean - eMin)/(eMax-eMin));
        const colorFromValue = (v)=>{ const c = new THREE.Color(); c.setHSL(0.66 - 0.66*v, 1.0, 0.5); return [c.r,c.g,c.b]; };
        this.nodes = this.syllables.map((sy,i)=>{
          const p = (embedded[i] || [Math.random()-0.5, Math.random()-0.5, Math.random()-0.5]);
          const v = val(sy);
          return { id: sy.id, position: [p[0],p[1],p[2]], value: v, color: colorFromValue(v), size: 0.02 + 0.05*v, startTime: sy.startTime, endTime: sy.endTime, energyMean: sy.energyMean, frameCount: sy.frameCount };
        });
        this.neighbors = this.reducer.knn(6);
        if (!this.frozen) this.vis.setData(this.nodes, this.neighbors);
      }
    }

    // bootstrap
    const app = new App();

    // cleanup
    window.addEventListener('beforeunload', ()=>{ try{ app.stop(); }catch(e){} });
  </script>
</body>
</html>
