<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <title>Coordinatix 3D </title>
  <style>
    /* --- CSS unchanged from your original code --- */
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
    body, html { width: 100%; height: 100%; overflow: auto; }
    #canvas-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; background-color: #000; overflow: hidden; }
    #sidebar { position: fixed; top: 30px; left: 30px; width: 300px; height: calc(100vh - 60px); overflow-y: auto; padding: 20px; background: rgba(255, 255, 255, 0.2); border-radius: 16px; z-index: 10; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3); backdrop-filter: blur(10px); color: #fff; }
    #sidebar h2 { font-size: 1.5em; margin-bottom: 20px; }
    .equation-input { width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid rgba(255,255,255,0.4); border-radius: 6px; background: rgba(255, 255, 255, 0.3); color: #fff; }
    .equation-row { display: flex; align-items: center; margin-bottom: 10px; }
    .equation-input { flex: 1; padding: 10px; border: 1px solid rgba(255, 255, 255, 0.135); border-radius: 6px 0 0 6px; background: rgba(255, 255, 255, 0.011); color: #ffffff; margin: 0; }
    button { padding: 10px 14px; margin: 5px 0; border: none; border-radius: 6px; cursor: pointer; background: #00aaff; color: white; transition: background 0.2s ease; }
    button:hover { background: #0077cc00; }
    .remove-btn { padding: 10px 14px; background: rgba(255, 80, 80, 0); color: white; border: none; cursor: pointer; border-radius: 0 6px 6px 0; height: 100%; font-size: 1.2em; }
    .remove-btn:hover { transform: scale(1.2); }
    #error { color: #ff8888; font-size: 0.9em; margin-top: 10px; }
    @media (max-width: 768px) { #sidebar { width: 90%; left: 5%; } }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>Coordinatix</h2>
    <div id="equations"></div>
    <div id="error"></div>
  </div>
  <div id="canvas-container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.0/math.min.js"></script>


  <script>
    let scene, camera, renderer, controls;
    const equations = [];
    const meshes = [];
    const range = 10;
    const resolution = 100;

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(5, 5, 10);

      renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.AxesHelper(5));
      scene.add(new THREE.GridHelper(20, 20));
      // Soft upper right corner lighting setup
      scene.add(new THREE.AmbientLight(0xffffff, 0.35));
      
      // Softer main light from upper-right corner
      const cornerLight = new THREE.DirectionalLight(0xffffff, 0.75);
      cornerLight.position.set(12, 10, 8);
      cornerLight.castShadow = true;
      cornerLight.shadow.mapSize.width = 2048;
      cornerLight.shadow.mapSize.height = 2048;
      cornerLight.shadow.radius = 2; // Add some shadow softening
      scene.add(cornerLight);
      
      // Slightly stronger fill light for softer shadows
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.15);
      fillLight.position.set(-2, 0, 2);
      scene.add(fillLight);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    }

    // Converts a math.js AST to GLSL-safe code
function mathjsToGLSL(node) {
  switch (node.type) {
    case 'SymbolNode':
      if (['x', 'y', 'z', 't'].includes(node.name)) return node.name;
      throw new Error(`Unsupported variable: ${node.name}`);
    case 'ConstantNode':
      // Ensure all numbers become floats in GLSL (e.g., 2 → 2.0)
      if (typeof node.value === 'number') {
    return node.value.toString().includes('.') ? node.value : `${node.value}.0`;
      }
       return node.value;

    case 'OperatorNode':
      const args = node.args.map(mathjsToGLSL);
      switch (node.op) {
        case '+': return `${args[0]} + ${args[1]}`;
        case '-': return `${args[0]} - ${args[1]}`;
        case '*': return `${args[0]} * ${args[1]}`;
        case '/': return `${args[0]} / ${args[1]}`;
        case '^': return `pow(${args[0]}, ${args[1]})`;
      }
      throw new Error(`Unsupported operator: ${node.op}`);
    case 'FunctionNode':
      const fn = node.name;
      const params = node.args.map(mathjsToGLSL).join(', ');
      if (['sin','cos','tan','exp','log','sqrt','abs'].includes(fn)) {
        return `${fn}(${params})`;
      }
      throw new Error(`Unsupported function: ${fn}`);
    default:
      throw new Error(`Unsupported node type: ${node.type}`);
  }
}

// Safe wrapper to parse & convert a user equation into GLSL
function safeToGLSL(exprString) {
  const node = math.parse(exprString);
  return mathjsToGLSL(node);
}


function createShaderMaterial(equationGLSL, color) {
  return new THREE.ShaderMaterial({
    vertexShader: `
      varying vec3 vColor;
      varying vec3 vPosition;
      varying vec3 vNormal;

      float f(float x, float y) {
        return ${equationGLSL};
      }

      void main() {
        float x = position.x;
        float y = position.y;
        float z = f(x, y);
        
        // Calculate surface normal for shading
        float eps = 0.01;
        float dx = (f(x + eps, y) - f(x - eps, y)) / (2.0 * eps);
        float dy = (f(x, y + eps) - f(x, y - eps)) / (2.0 * eps);
        vec3 normal = normalize(vec3(-dx, -dy, 1.0));
        
        vPosition = vec3(x, y, z);
        vNormal = normal;
        vColor = vec3(${color.r.toFixed(2)}, ${color.g.toFixed(2)}, ${color.b.toFixed(2)});

        gl_Position = projectionMatrix * modelViewMatrix * vec4(vPosition, 1.0);
      }
    `,
    fragmentShader: `
      varying vec3 vColor;
      varying vec3 vPosition;
      varying vec3 vNormal;

      void main() {
        // Soft upper right corner light
        vec3 cornerLight = normalize(vec3(0.8, 0.6, 0.4));
        float diffuse = max(dot(vNormal, cornerLight), 0.0);
        
        // Soften the lighting transition
        diffuse = smoothstep(0.0, 1.0, diffuse);
        
        // Create lighter shadows with more subtle transitions
        vec3 shadedColor = vColor * (0.45 + 0.55 * diffuse);
        gl_FragColor = vec4(shadedColor, 1.0);
      }
    `,
    side: THREE.DoubleSide,
    wireframe: false
  });
}




    function updateEquation(index, text) {
  let equationGLSL;
  try {
    equationGLSL = safeToGLSL(text.trim()); // ✅ parse & convert properly
  } catch (err) {
    document.getElementById('error').innerText = `Invalid equation: ${err.message}`;
    return;
  }

  document.getElementById('error').innerText = '';

  // remove old mesh if it exists
  if (meshes[index]) {
    scene.remove(meshes[index]);
    meshes[index].geometry.dispose();
    meshes[index].material.dispose();
    meshes[index] = null;
  }

  if (!text.trim()) return;

  try {
    const geometry = new THREE.PlaneGeometry(range * 2, range * 2, resolution, resolution);
    const color = new THREE.Color(equations[index].color);
    const material = createShaderMaterial(equationGLSL, color); // ✅ use parsed GLSL here

    const mesh = new THREE.Mesh(geometry, material);
    meshes[index] = mesh;
    scene.add(mesh);
  } catch (e) {
    document.getElementById('error').innerText = `Error in equation ${index + 1}: ${e.message}`;
  }
}


    function addEquation(equationText = '') {
      const container = document.getElementById('equations');
      const index = equations.length;
      equations.push({ text: equationText, color: getRandomColor() });

      const row = document.createElement('div');
      row.className = 'equation-row';

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'equation-input';
      input.placeholder = 'Enter equation (e.g., sin(x) + cos(y))';
      input.value = equationText;

      const removeBtn = document.createElement('button');
      removeBtn.className = 'remove-btn';
      removeBtn.innerHTML = `<img src="images/svg.svg" alt="Delete" width="16" height="16">`;

      removeBtn.onclick = () => {
        equations[index] = null;
        if (meshes[index]) {
          scene.remove(meshes[index]);
          meshes[index].geometry.dispose();
          meshes[index].material.dispose();
          meshes[index] = null;
        }
        container.removeChild(row);
        const remainingRows = document.querySelectorAll('.equation-row').length;
        while (remainingRows < 2) {
          addEquation('');
          break;
        }
      };

      input.oninput = () => {
        updateEquation(index, input.value);
        const inputs = document.querySelectorAll('.equation-input');
        const isLast = input === inputs[inputs.length - 1];
        if (isLast && input.value.trim() !== '') {
          addEquation('');
        }
      };

      row.appendChild(input);
      row.appendChild(removeBtn);
      container.appendChild(row);

      updateEquation(index, equationText);
    }

    function getRandomColor() {
      return `#${Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0')}`;
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    init();
    addEquation('sin(x) + cos(y)');
    addEquation('');
  </script>
</body>
</html>