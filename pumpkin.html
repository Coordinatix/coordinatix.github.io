<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>PUMPKIN PANIC - Halloween Survival Game</title>
  <meta name="description" content="Help the magic pumpkin escape the evil witch in this spooky Halloween survival runner!" />
  
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      background: #000;
      color: #fff;
      font-family: 'Creepster', 'Comic Sans MS', cursive;
      overflow: hidden;
      touch-action: manipulation;
    }
    canvas { display:block; margin:0 auto; background:#111; }
    #title {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
      pointer-events: none;
    }
    h1 {
      font-size: 4rem;
      color: #ff8800;
      text-shadow: 0 0 20px #ff0000;
      animation: glow 2s infinite alternate;
    }
    @keyframes glow {
      from { text-shadow: 0 0 20px #ff0000; }
      to { text-shadow: 0 0 40px #ff8800, 0 0 60px #ff4400; }
    }
    .btn {
      margin-top: 30px;
      padding: 15px 40px;
      font-size: 1.8rem;
      background: #ff4400;
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 0 30px #ff0000;
      transition: all 0.3s;
    }
    .btn:hover { transform: scale(1.1); box-shadow: 0 0 50px #ff8800; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      z-index: 5;
      pointer-events: none;
      font-size: 1.2rem;
    }
    #healthBar {
      height: 30px;
      width: 300px;
      background: #333;
      border: 3px solid #fff;
      border-radius: 15px;
      overflow: hidden;
      display: inline-block;
    }
    #health { height:100%; width:100%; background: linear-gradient(to right, red, yellow, lime); transition: width 0.3s; }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Creepster&display=swap" rel="stylesheet">
</head>
<body>

  <div id="title" style="display:none;">
    <h1>PUMPKIN PANIC</h1>
    <button class="btn" onclick="startGame()">PLAY NOW</button>
    <p style="margin-top:20px; font-size:1.2rem;">Use WASD or Arrow Keys â€¢ Survive the Witch!</p>
  </div>

  <div id="ui" style="display:none;">
    <div style="display:flex; justify-content:space-between;">
      <div>
        <div id="healthBar"><div id="health"></div></div><br>
        Score: <span id="score">0</span> | Coins: <span id="coins">0</span>
      </div>
      <button class="btn" style="font-size:1rem; padding:10px 20px;" onclick="location.reload()">MENU</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script>
// PUMPKIN PANIC - Full Game (Website Version)
// Made with love for the Holiday Cup

let scene = "menu";
let loading = true;
let pumpkin = { x: 400, y: 300, vx: 0, vy: 0, radius: 22, skin: 0, trail: [] };
let witch = { x: 400, y: 300, path: [], speed: 1.8 };
let health = 100, score = 0, coins = 0, gameTime = 0;
let keys = {}, particles = [], crystals = [];
let camX = 0, camY = 0;
let tileSize = 50;
let mapOffsetX = -400, mapOffsetY = -400;

const map = [
  "################################",
  "#------------------------------#",
  "#----##########----------------#",
  "#----#--------#----###---------#",
  "#----#--####--#----#-#----------#",
  "#----#--#--#--#----#-#----------#",
  "#----#--#--#--#####-#-----------#",
  "#----#--#--#--------#-----------#",
  "#----#--#--##########-----------#",
  "#----#--------------------------#",
  "#----#####------###-------------#",
  "#--------------------------------#",
  "################################"
];

const skins = [
  (x,y) => { // Classic
    fill(255,140,0); ellipse(x,y,44,44);
    fill(255,200,0); triangle(x-10,y-8,x,y+8,x+10,y-8);
    fill(0); ellipse(x-10,y-5,8,12); ellipse(x+10,y-5,8,12);
    arc(x,y+5,20,10,0,180);
  },
  (x,y) => { // Ghost
    fill(200,240,255,220); ellipse(x,y,48,48);
    fill(100,180,255); ellipse(x-10,y-8,10,15); ellipse(x+10,y-8,10,15);
    fill(0); ellipse(x-8,y-6,6,6); ellipse(x+8,y-6,6,6);
  },
  (x,y) => { // Fire
    fill(255,80,0); ellipse(x,y,44,44);
    fill(255,180,0);
    for(let i=0;i<5;i++){
      let a=i*72; ellipse(x+cos(a)*18,y+sin(a)*18-10,16,24);
    }
  }
];

function preload() {
  // Generate crystals
  for(let y=0; y<map.length; y++){
    for(let x=0; x<map[y].length; x++){
      if(map[y][x]==='c' || (random()<0.03 && map[y][x]==='-')){
        crystals.push({
          x: x*tileSize + tileSize/2 + mapOffsetX,
          y: y*tileSize + tileSize/2 + mapOffsetY,
          active: true
        });
      }
    }
  }
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  textAlign(CENTER, CENTER);
  textFont('Creepster');
  document.getElementById("title").style.display = "block";
}

function startGame() {
  document.getElementById("title").style.display = "none";
  document.getElementById("ui").style.display = "block";
  scene = "game";
  pumpkin.x = width/2; pumpkin.y = height/2;
  witch.x = random(200,600); witch.y = random(200,600);
  health = 100; score = 0; gameTime = 0;
  crystals.forEach(c=>c.active=true);
}

function findPath(sx, sy, ex, ey) {
  sx = floor((sx - mapOffsetX)/tileSize);
  sy = floor((sy - mapOffsetY)/tileSize);
  ex = floor((ex - mapOffsetX)/tileSize);
  ey = floor((ey - mapOffsetY)/tileSize);
  
  let open = [], cameFrom = {}, gScore = {};
  let start = sx+","+sy, goal = ex+","+ey;
  gScore[start] = 0;
  open.push({x:sx, y:sy, f:dist(sx,sy,ex,ey)});
  
  while(open.length){
    open.sort((a,b)=>b.f-a.f);
    let cur = open.pop();
    let key = cur.x+","+cur.y;
    if(key===goal){
      let path = [];
      while(key in cameFrom){
        let [cx,cy] = key.split(",").map(Number);
        path.push({x:cx*tileSize+tileSize/2+mapOffsetX, y:cy*tileSize+tileSize/2+mapOffsetY});
        key = cameFrom[key];
      }
      return path.reverse();
    }
    for(let [dx,dy] of [[0,1],[1,0],[0,-1],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]){
      let nx=cur.x+dx, ny=cur.y+dy, nkey=nx+","+ny;
      if(nx<0||ny<0||nx>=map[0].length||ny>=map.length||map[ny][nx]==='#') continue;
      let tentG = gScore[key] + (dx&&dy?1.4:1);
      if(!gScore[nkey] || tentG < gScore[nkey]){
        cameFrom[nkey] = key;
        gScore[nkey] = tentG;
        open.push({x:nx,y:ny,f:tentG+dist(nx,ny,ex,ey)});
      }
    }
  }
  return [];
}

function draw() {
  background(20,10,40);
  
  if(scene==="menu" || scene==="game"){
    // Camera
    camX += (pumpkin.x - width/2 - camX)*0.1;
    camY += (pumpkin.y - height/2 - camY)*0.1;
    translate(width/2 - camX, height/2 - camY);
    
    // Draw map
    for(let y=0; y<map.length; y++){
      for(let x=0; x<map[y].length; x++){
        if(map[y][x]==='#'){
          fill(40,20,10); rect(x*tileSize+mapOffsetX, y*tileSize+mapOffsetY, tileSize, tileSize);
          fill(20,10,0); rect(x*tileSize+mapOffsetX+5, y*tileSize+mapOffsetY+5, tileSize-10, tileSize-10);
        }
      }
    }
    
    // Crystals
    crystals.forEach(c=>{
      if(!c.active) return;
      push();
      translate(c.x, c.y + sin(frameCount*0.1)*5);
      rotate(frameCount*0.05);
      fill(100,255,255);
      for(let i=0;i<6;i++){ rotate(60); triangle(0,-25,-15,10,15,10); }
      pop();
      if(dist(pumpkin.x,pumpkin.y,c.x,c.y)<50){
        health = min(100, health+30);
        c.active = false;
        for(let i=0;i<20;i++){
          particles.push({x:c.x,y:c.y,vx:random(-4,4),vy:random(-6,-2),life:60,col:color(100,255,255)});
        }
      }
    });
    
    // Player movement
    let speed = keys[16]?0.5:0.3;
    if(keys[87]||keys[UP]) pumpkin.vy -= speed;
    if(keys[83]||keys[DOWN]) pumpkin.vy += speed;
    if(keys[65]||keys[LEFT]) pumpkin.vx -= speed;
    if(keys[68]||keys[RIGHT]) pumpkin.vx += speed;
    pumpkin.vx *= 0.88; pumpkin.vy *= 0.88;
    
    // Collision
    let nextX = pumpkin.x + pumpkin.vx;
    let nextY = pumpkin.y + pumpkin.vy;
    let blockedX = false, blockedY = false;
    for(let y=0; y<map.length; y++){
      for(let x=0; x<map[y].length; x++){
        if(map[y][x]!=='#') continue;
        let rx = x*tileSize + mapOffsetX;
        let ry = y*tileSize + mapOffsetY;
        if(circleRect(nextX, pumpkin.y, pumpkin.radius, rx, ry, tileSize, tileSize)) blockedX = true;
        if(circleRect(pumpkin.x, nextY, pumpkin.radius, rx, ry, tileSize, tileSize)) blockedY = true;
      }
    }
    if(!blockedX) pumpkin.x = nextX;
    if(!blockedY) pumpkin.y = nextY;
    
    // Trail
    pumpkin.trail.push({x:pumpkin.x, y:pumpkin.y, a:255});
    if(pumpkin.trail.length>15) pumpkin.trail.shift();
    pumpkin.trail.forEach(t=>{ t.a-=15; fill(255,100,0,t.a); ellipse(t.x,t.y,40); });
    
    // Draw player
    push();
    translate(pumpkin.x, pumpkin.y);
    rotate(atan2(pumpkin.vy, pumpkin.vx)+90);
    skins[pumpkin.skin](0,0);
    pop();
    
    // Witch AI
    if(dist(pumpkin.x,pumpkin.y,witch.x,witch.y)<300){
      if(frameCount%20===0 || witch.path.length===0){
        let tx = (pumpkin.x-mapOffsetX)/tileSize;
        let ty = (pumpkin.y-mapOffsetY)/tileSize;
        witch.path = findPath((witch.x-mapOffsetX)/tileSize, (witch.y-mapOffsetY)/tileSize, tx, ty);
      }
    }
    if(witch.path.length){
      let tgt = witch.path[0];
      let dx = tgt.x - witch.x;
      let dy = tgt.y - witch.y;
      let d = dist(witch.x,witch.y,tgt.x,tgt.y);
      if(d<10) witch.path.shift();
      else {
        witch.x += dx/d * witch.speed;
        witch.y += dy/d * witch.speed;
      }
    }
    
    // Draw witch
    push();
    translate(witch.x, witch.y);
    fill(80,0,120); ellipse(0,0,50,60);
    fill(0); triangle(-20,-20,20,-20,0,-50);
    fill(200,100,255); ellipse(-10,-10,10,10); ellipse(10,-10,10,10);
    pop();
    
    // Damage
    if(dist(pumpkin.x,pumpkin.y,witch.x,witch.y)<50){
      health -= 1.5;
      fill(255,0,0,100); ellipse(pumpkin.x,pumpkin.y,100,100);
    }
    
    // Game logic
    health -= 0.03;
    gameTime++;
    score = floor(gameTime/10);
    document.getElementById("health").style.width = health*3 + "px";
    document.getElementById("score").textContent = score;
    
    if(health<=0){
      coins += floor(score/10);
      alert("CAUGHT! You earned " + floor(score/10) + " coins!");
      location.reload();
    }
    if(gameTime>15000){
      coins += 500;
      alert("YOU ESCAPED! +500 coins bonus!");
      location.reload();
    }
  }
  
  // Particles
  for(let i=particles.length-1; i>=0; i--){
    let p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life--;
    fill(red(p.col),green(p.col),blue(p.col),p.life*4);
    ellipse(p.x,p.y,12);
    if(p.life<=0) particles.splice(i,1);
  }
}

function circleRect(cx,cy,r,rx,ry,rw,rh){
  let testX=cx, testY=cy;
  if(cx<rx) testX=rx;
  else if(cx>rx+rw) testX=rx+rw;
  if(cy<ry) testY=ry;
  else if(cy>ry+rh) testY=ry+rh;
  return dist(cx,cy,testX,testY)<=r;
}

window.keyPressed = () => keys[keyCode]=true;
window.keyReleased = () => keys[keyCode]=false;
window.mousePressed = () => { if(scene==="menu") startGame(); }
window.touchStarted = () => { if(scene==="menu") startGame(); }
  </script>
</body>
</html>